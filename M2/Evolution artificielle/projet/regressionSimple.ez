/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.

  use : easea -gp regression.ez
	make

	OR (if you'd like to exploit a CUDA-compatible graphic card)

	easea -cuda_gp regression.ez
        make

  in order to generate and compile this code.
__________________________________________________________*/

\User declarations :
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>
#include <cmath>
#include <vector>

#define GROW_FULL_RATIO 0.5
// nombre de colonne dans le ficheir CSV
//derniere colonne contient le r√©sultat
//premieres colonnes contiennent les variables
#define VAR_LEN 7
#define CSV_FILENAME "data.csv"

// this is the number of learning cases computed in parallel.
// note that on 1024 is the maximum size on fermi architectures 512 on older cards.
#define NUMTHREAD 1024
#define MAX_STACK 15

#define PI (3.141592653589793)

int NO_FITNESS_CASES;

\end

\User functions:

std::vector<std::string> split(std::string str,std::string sep)
{
    char* cstr=const_cast<char*>(str.c_str());
    char* current;
    std::vector<std::string> arr;
    current=strtok(cstr,sep.c_str());
    while(current!=NULL)
	{
        arr.push_back(current);
        current=strtok(NULL,sep.c_str());
    }
    return arr;
}

std::vector<float> toFloats(std::vector<std::string> arr)
{
	std::vector<float> floats;
	for(size_t i = 0; i != arr.size(); i++)
	{
		floats.push_back(std::stof(arr[i]));
	}
	return floats;
}

int loadData(float*** inputs, float** outputs)
{
	std::ifstream file(CSV_FILENAME);
	if(file.is_open())
	{
		std::string line;
		std::vector<float> arr;
		std::vector<std::vector<float>> datas;
		while(file.good())
		{
			std::getline(file, line);
			arr = toFloats(split(line, ";"));
			if(arr.size() == VAR_LEN)
			{
				datas.push_back(arr);
			}
		}
		file.close();
		
		(*inputs) = new float*[datas.size()];
		(*outputs) = new float[datas.size()];
		
		for(size_t i = 0; i != datas.size(); i++)
		{
			(*inputs)[i] = new float[VAR_LEN];
			for(int j=0; j<VAR_LEN-1; j++)
			{
				(*inputs)[i][j] = datas[i][j];
			}
			(*outputs)[i] = datas[i][VAR_LEN - 1];
		}
		NO_FITNESS_CASES = datas.size();
		
		/*
		//PRINT DATAS
		for(size_t i = 0; i < NO_FITNESS_CASES; i++)
		{
			for(int j=0; j<VAR_LEN-1; j++)
			{
				std::cout << (*inputs)[i][j] << "    ";
			}
			std::cout << (*outputs)[i] << std::endl;
		}
		*/
		
		return datas.size();
	}
	else
	{
		std::cout << "Le fichier " << CSV_FILENAME << " n'existe pas." << std::endl;
		std::exit(EXIT_FAILURE);
	}
}


void free_data(){
  for( int i=0 ; i<NO_FITNESS_CASES ;i++ ) delete[] inputs[i] ;

  delete[] outputs;
  delete[] inputs;
} 
\end



\Before everything else function:
{
  loadData(&inputs,&outputs);
}
\end

\After everything else function:
{

  std::cout << "formule trouvÈe : " << std::endl;
  std::cout <<  toString(((IndividualImpl*)EA->population->Best)->root) << std::endl;
  std::cout << "std dev : " << bBest->evaluate() << std::endl;
  free_data();
}
\end

\At the beginning of each generation function:
{
  //cout << "At the beginning of each generation function called" << endl;
}		    
\end

\At the end of each generation function:
{		 
  //cout << "At the end of each generation function called" << endl;
}
\end

\At each generation before reduce function:
 //cout << "At each generation before replacement function called" << endl;
\end


\User classes :

GenomeClass {
  GPNode* root;
}
\end

\GenomeClass::display:

\end

\GenomeClass::initialiser :
{
  Genome.root = ramped_hh();
}
\end

\GenomeClass::crossover :
{
  simpleCrossOver(parent1,parent2,child);
  child.valid = false;
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{
  simple_mutator(&Genome);

  return 1;
}
\end


\begin operator description :
OP_A, "xA2", 0, {RESULT=INPUT[0];};
OP_B, "xB2", 0, {RESULT=INPUT[1];};
OP_C, "xC2", 0, {RESULT=INPUT[2];};
OP_D, "xD2", 0, {RESULT=INPUT[3];};
OP_E, "xE2", 0, {RESULT=INPUT[4];};
OP_F, "xF2", 0, {RESULT=INPUT[5];};
OP_ERC, "ERC", 0,{RESULT=ERC;};
OP_ADD, "+", 2, {RESULT=OP1+OP2;};
OP_SUB, "-", 2, {RESULT=OP1-OP2;};
OP_MUL, "*", 2, {RESULT=OP1*OP2;};
OP_DIV, "/", 2, {
  if( !OP2 ) RESULT = 1;
  else RESULT = OP1/OP2;
};
OP_LN, "ln", 1, {RESULT=std::log(OP1);};
OP_NEG, "neg", 1, {RESULT=-OP1;};
OP_INV, "inv", 1, {
  if( !OP1 ) RESULT = 1;
  else RESULT = 1/OP1;
};
\end


\GenomeClass::evaluator header:
\end

\GenomeClass::evaluator for each fc :
	float expected_value = OUTPUT;
	ERROR = (expected_value-EVOLVED_VALUE)*(expected_value-EVOLVED_VALUE);
\end

\GenomeClass::evaluator accumulator :
	return ERROR;
\end


\User Makefile options: 

CXXFLAGS+=
LDFLAGS+=
CXX=g++

\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 200   	// NB_GEN
  Time limit: 0 			// In seconds, 0 to deactivate
  Population size : 32768			//POP_SIZE
  Offspring size : 40% 
  Mutation probability : 0.01       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : minimise      // Maximise
  Selection operator: Tournament 7
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 7

  Elitism: Strong			//Weak or Strong
  Elite: 1
  Print stats: true				//Default: 1
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:false				//Default: 0

  //  Remote island model: true
  //IP	  file: ip.txt 			//File containing all the remote island's IP
  //Server port : 2929
  //Migration probability: 0.33

  Save population: false
  Start from file:false

  max init tree depth : 4
  min init tree depth : 2

  max tree depth : 8

  size of prog buffer : 200000000
\end
