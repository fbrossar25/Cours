Programmer pour apprendre le mouvement des pièces aux échecs
Couleur type énumeré.
position deux entiers entre 1 et 8
pièce : classe abstraite avec
	-position
	-couleur
	-moveOK(position arr)
sous classes concrètes:
	-Fou,Pion,Roi,Reine,Tour,Cavalier
redéfinir moveOK(Position arr) pour chacune des ces pièces concrètes
toString() :
	-Fou : F
	-Pion : i
	-Reine : *
	-Roi : t
	-Tour : T
	-Cavalier : L

class Position{
	private int x;
	private int y;
	Position(){
		Position(1,1)
	}
	Position(int x, int y){
		if(x > 0 && x < 9 && y >0 && y <9){
			moi.x = x;
			moi.y = y;
		}
		else{
			moi.x = 1;
			moi.y = 1;
		}
	}
	int getX(){
		return x;
	}
	int getY(){
		return y;
	}
}

public abstract class Piece{
	protected Position pos
	enum Color {white,black}
	protected color
	Piece(){
		moi(Position créer(1,1),Color créer(Blanc))
	}
	Piece(Position pos,Color color){
		moi.color = color
		if(pos.getX() > 0 && pos.getX() < 9 && pos.getY() > 0 && pos.getX() > 9){
			moi.pos = pos
		}
		else moi.pos = new Position() 
	}
	
	abstract boolean moveOK(Position target)
	
	static int deltaX(Position source,Position target){
		return source.getX() - target.getX()
	}
	
	static int deltaY(Position source, Position target){
		return source.getY() - source.getY()
	}
	
	static boolean isHorizontalMove(Position source,Position target){
		return deltaY(source,target) == 0
	}
	
	static boolean isVerticalMove(Position source,Position target){
		return deltaX(source,target) == 0
	}
	
	static boolean isDiagonalMove(Position source, Position target){
		return (Math.abs(deltaX(source,target)) == Math.abs(deltaY(source,target)))
	}
}

public class Cavalier extends Piece{
	boolean moveOK(Postion target){
		return ((Math.abs(deltaY(pos,target)==2) && (Math.abs(deltaX(pos,target)) == 1)) || ((Math.abs(deltaY(pos,target)==1) && (Math.abs(deltaX(pos,target)) == 2))
	}
}

public class Fou extends Piece{
	boolean moveOK(Postion target){
		return isDiagonalMove(pos,target)
	}
}

public class Reine extends Piece{
	boolean moveOK(Postion target){
		return isDiagonalMove(pos,target) || isHorizontalMove(pos,target) ||isVerticalMove(pos,target)
	}
}

public class Roi exentds Piece{
	boolean moveOK(Postion target){
		return (Math.abs(deltaX(pos,target)) == 1) || (Math.abs(deltaY(pos,target)) == 1)
	}
}

public class Tour extends Piece{
	boolean moveOK(Positon target){
		boolean a = isHorizontalMove(pos,target)
		boolean b = isVerticalMove(pos,target)
		return (a && !b) || (!a && b)
	}
}

public class Pion extends Piece{
	boolean moveOK(Position target){
		//on suppose que les blanc sont en bas
		if(color == white){
			if(pos.getY() == 2)return deltaY(pos,target) == 2 || deltaY(pos,target) == 1
			else return deltaY(pos,target) == 1
		}
		else{
			if(pos.getY() == 7)return deltaY(pos,target) == -2 || deltaY(pos,target) == -1
			else return deltaY(pos,target) == -1
		}
	}
}