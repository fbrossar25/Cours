/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.

  use : easea -gp regression.ez
	make

	OR (if you'd like to exploit a CUDA-compatible graphic card)

	easea -cuda_gp regression.ez
        make

  in order to generate and compile this code.
__________________________________________________________*/

\User declarations :
#include<math.h>
#include<stdlib.h>
// these 3 defines are mandatory here. Adjust as you like.
#define NO_FITNESS_CASES 80
#define VAR_LEN 1
#define GROW_FULL_RATIO 0.5

// this is the number of learning cases computed in parallel.
// note that on 1024 is the maximum size on fermi architectures 512 on older cards.
#define NUMTHREAD 80
#define MAX_STACK 15


#define PI (3.141592653589793)
\end

\User functions:
//#define POLY(x) 5*cos(2*x+1)
/**
   This function generates data NO_FITNESS_CASES fitness cases,
   from the polynome POLY(X) with X randomly picked between (-1,1)

   @inputs address of the inputs array. (array will be allocated here)
   @outputs adddress of the outputs array. (array will be allocated here)

   @ret number of loaded fitness cases (should be equal to NO_FITNESS_CASES).   
 */
int generateData(float*** inputs, float** outputs){
  int i=0;

  (*inputs) = new float*[NO_FITNESS_CASES];
  (*outputs) = new float[NO_FITNESS_CASES];
  
  /*
  for( i=0 ; i<NO_FITNESS_CASES ; i++ ){
    (*inputs)[i]=new float[VAR_LEN];
    float x = random(-10.,+10.);
    (*inputs)[i][0] = x;
    (*outputs)[i] = POLY(x);
  }
  */

  for( i=0 ; i<NO_FITNESS_CASES ; i++ )
      (*inputs)[i]=new float[VAR_LEN];

(*inputs)[0][0] = 10307;   (*outputs)[0]=30920;
  (*inputs)[1][0] = 10487;   (*outputs)[1]=30194;
  (*inputs)[2][0] = 16639;   (*outputs)[2]=29532;
  (*inputs)[3][0] = 16819;   (*outputs)[3]=29471;
  (*inputs)[4][0] = 22938;   (*outputs)[4]=29782;
  (*inputs)[5][0] = 22945;   (*outputs)[5]=29255;
  (*inputs)[6][0] = 29249;   (*outputs)[6]=28197;
  (*inputs)[7][0] = 29457;   (*outputs)[7]=28460;
  (*inputs)[8][0] = 35576;   (*outputs)[8]=27744;
  (*inputs)[9][0] = 35756;   (*outputs)[9]=27629;
  (*inputs)[10][0] = 41936;  (*outputs)[10]=26808;
  (*inputs)[11][0] = 41943;  (*outputs)[11]=26485;
  (*inputs)[12][0] = 48221;  (*outputs)[12]=25156;
  (*inputs)[13][0] = 48303;  (*outputs)[13]=24870;
  (*inputs)[14][0] = 54408;  (*outputs)[14]=24264;
  (*inputs)[15][0] = 54588;  (*outputs)[15]=24176;
  (*inputs)[16][0] = 60588;  (*outputs)[16]=22571;
  (*inputs)[17][0] = 60782;  (*outputs)[17]=23287;
  (*inputs)[18][0] = 67046;  (*outputs)[18]=21568;
  (*inputs)[19][0] = 67212;  (*outputs)[19]=22254;
  (*inputs)[20][0] = 73219;  (*outputs)[20]=20566;
  (*inputs)[21][0] = 73441;  (*outputs)[21]=20913;
  (*inputs)[22][0] = 79663;  (*outputs)[22]=19663;
  (*inputs)[23][0] = 79885;  (*outputs)[23]=19359;
  (*inputs)[24][0] = 85878;  (*outputs)[24]=18220;
  (*inputs)[25][0] = 86072;  (*outputs)[25]=18280;
  (*inputs)[26][0] = 92308;  (*outputs)[26]=17273;
  (*inputs)[27][0] = 92474;  (*outputs)[27]=17210;
  (*inputs)[28][0] = 98460;  (*outputs)[28]=15667;
  (*inputs)[29][0] = 98654;  (*outputs)[29]=16315;
  (*inputs)[30][0] = 104675; (*outputs)[30]=14463;
  (*inputs)[31][0] = 105042; (*outputs)[31]=14883;
  (*inputs)[32][0] = 111049; (*outputs)[32]=13969;
  (*inputs)[33][0] = 111313; (*outputs)[33]=14034;
  (*inputs)[34][0] = 117451; (*outputs)[34]=12977;
  (*inputs)[35][0] = 117743; (*outputs)[35]=12897;
  (*inputs)[36][0] = 123736; (*outputs)[36]=11851;
  (*inputs)[37][0] = 123916; (*outputs)[37]=11830;
  (*inputs)[38][0] = 130124; (*outputs)[38]=11129;
  (*inputs)[39][0] = 130360; (*outputs)[39]=11058;
  (*inputs)[40][0] = 136131; (*outputs)[40]=9998;
  (*inputs)[41][0] = 136526; (*outputs)[41]=10259;
  (*inputs)[42][0] = 142491; (*outputs)[42]=9408;
  (*inputs)[43][0] = 142783; (*outputs)[43]=9496;
  (*inputs)[44][0] = 148804; (*outputs)[44]=8797;
  (*inputs)[45][0] = 149157; (*outputs)[45]=8842;
  (*inputs)[46][0] = 154928; (*outputs)[46]=7863;
  (*inputs)[47][0] = 155136; (*outputs)[47]=8189;
  (*inputs)[48][0] = 161358; (*outputs)[48]=7471;
  (*inputs)[49][0] = 161524; (*outputs)[49]=7404;
  (*inputs)[50][0] = 167573; (*outputs)[50]=6851;
  (*inputs)[51][0] = 167767; (*outputs)[51]=7003;
  (*inputs)[52][0] = 173933; (*outputs)[52]=6500;
  (*inputs)[53][0] = 174239; (*outputs)[53]=6348;
  (*inputs)[54][0] = 180293; (*outputs)[54]=6025;
  (*inputs)[55][0] = 180613; (*outputs)[55]=6014;
  (*inputs)[56][0] = 186286; (*outputs)[56]=5503;
  (*inputs)[57][0] = 186564; (*outputs)[57]=5960;
  (*inputs)[58][0] = 192702; (*outputs)[58]=5564;
  (*inputs)[59][0] = 193092; (*outputs)[59]=5273;
  (*inputs)[60][0] = 198709; (*outputs)[60]=5068;
  (*inputs)[61][0] = 199015; (*outputs)[61]=5170;
  (*inputs)[62][0] = 205300; (*outputs)[62]=4697;
  (*inputs)[63][0] = 205653; (*outputs)[63]=4776;
  (*inputs)[64][0] = 211429; (*outputs)[64]=4441;
  (*inputs)[65][0] = 211646; (*outputs)[65]=4443;
  (*inputs)[66][0] = 217964; (*outputs)[66]=4284;
  (*inputs)[67][0] = 218298; (*outputs)[67]=4248;
  (*inputs)[68][0] = 224013; (*outputs)[68]=4178;
  (*inputs)[69][0] = 224366; (*outputs)[69]=4129;
  (*inputs)[70][0] = 230123; (*outputs)[70]=4085;
  (*inputs)[71][0] = 230485; (*outputs)[71]=4056;
  (*inputs)[72][0] = 236464; (*outputs)[72]=3785;
  (*inputs)[73][0] = 236775; (*outputs)[73]=3877;
  (*inputs)[74][0] = 242866; (*outputs)[74]=3639;
  (*inputs)[75][0] = 243060; (*outputs)[75]=3508;
  (*inputs)[76][0] = 248822; (*outputs)[76]=3489;
  (*inputs)[77][0] = 249170; (*outputs)[77]=3395;
  (*inputs)[78][0] = 254857; (*outputs)[78]=3244;
  (*inputs)[79][0] = 255691; (*outputs)[79]=3234;

  return NO_FITNESS_CASES;
}


void free_data(){
  for( int i=0 ; i<NO_FITNESS_CASES ;i++ ) delete[] inputs[i] ;

  delete[] outputs;
  delete[] inputs;
} 
\end



\Before everything else function:
{
  generateData(&inputs,&outputs);
}
\end

\After everything else function:
{
  std::cout << toString(((IndividualImpl*)EA->population->Best)->root) << std::endl;

  free_data();
}
\end

\At the beginning of each generation function:
{
  //cout << "At the beginning of each generation function called" << endl;
}		    
\end

\At the end of each generation function:
{		 
  //cout << "At the end of each generation function called" << endl;
}
\end

\At each generation before reduce function:
 //cout << "At each generation before replacement function called" << endl;
\end


\User classes :

GenomeClass {
  GPNode* root;
}
\end

\GenomeClass::display:

\end

\GenomeClass::initialiser :
{
  Genome.root = ramped_hh();
}
\end

\GenomeClass::crossover :
{
  simpleCrossOver(parent1,parent2,child);
  child.valid = false;
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{
  simple_mutator(&Genome);

  return 1;
}
\end


\begin operator description :
OP_X, "x", 0, {RESULT=INPUT[0];};
OP_ERC, "ERC", 0, {RESULT=ERC;};
OP_ADD, "+", 2, {RESULT=OP1+OP2;};
OP_SUB, "-", 2, {RESULT=OP1-OP2;};
OP_MUL, "*", 2, {RESULT=OP1*OP2;};
OP_SIN, "sin", 1, {RESULT=sin(OP1);};
OP_EXP, "exp", 1, {RESULT=exp(OP1);};
OP_DIV, "/", 2, {
  if( !OP2 ) RESULT = OP1;
  else RESULT = OP1/OP2;
};

\end


\GenomeClass::evaluator header:
\end

\GenomeClass::evaluator for each fc :
//ERROR = pow(31000-EVOLVED_VALUE*OUTPUT,2);
ERROR = pow(OUTPUT-EVOLVED_VALUE,2);
\end

\GenomeClass::evaluator accumulator :
float eval=sqrtf(sqrtf(ERROR));
if (eval>400) return 400;
else return eval;
\end


\User Makefile options: 

CXXFLAGS+=
LDFLAGS+=
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 500   	// NB_GEN
  Time limit: 0 			// In seconds, 0 to deactivate
  Population size : 60000			//POP_SIZE
  Offspring size : 60000 // 40% 
  Mutation probability : 1       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : minimise      // Maximise
  Selection operator: Tournament 7
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 3

  Elitism: Strong			//Weak or Strong
  Elite: 1
  Print stats: true				//Default: 1
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				//Default: 0

  Remote island model: true
  IP	  file: ip.txt 			//File containing all the remote island's IP
  Server port : 2929
  Migration probability: 0.33

  Save population: false
  Start from file:false

  max init tree depth : 3
  min init tree depth : 2
  max tree depth : 5

  size of prog buffer : 200000000
\end
