/*________________________________________________________________________________________________
Projet de recherche stochastique : Université de Strasbourg (2017-2018) M1 ILC
Brossard Florian
Dvornichenko Kateryna
Création d'un emplois du temps
________________________________________________________________________________________________*/

\User declarations:
	#include <string>
	#include <cstring>
	#include <iostream>

	#define PENALITE_OBLIGATOIRE 	10000
	#define PENALITE_FORTE			1000
	#define PENALITE_FAIBLE			1

	//Jours de la semaine
	#define JOUR_LUNDI 0
	#define JOUR_MARDI 1
	#define JOUR_MERCREDI 2
	#define JOUR_JEUDI 3
	#define JOUR_VENDREDI 4

	#define NB_JOURS 180 //52 semaines avec 5 jours d'écoles - 16 semaines de vacances
	#define NB_CRENEAUX_JOUR 4 		// 4 creneaux par jours
	#define NB_CRENEAUX 720 //NB_JOURS * NB_CRENEAUX_JOUR

	#define GROUPE_LIBRE -1		// Pour indiquer l'absence de groupe
	#define SPEC_L0 0			// Pas de spécialisation en L0
	#define SPEC_CE	1			// Chemical Engineering
	#define SPEC_CS	2			// Computer Science
	#define SPEC_GE	3			// Geophysical Engineering
	#define SPEC_OG	4			// Oil and Gas
	#define NB_SPECIALITES 5 	//(L0, CE, CS, GE, OG)

	#define SALLE_CM 0			//Salle CM
	#define SALLE_TD 1			//Salle TD
	#define SALLE_LANG 2		//Salle langue
	#define SALLE_INFO 3		//Salle info
	#define SALLE_LABO 4		//Salle physique-chimie

	#define CAPACITE_SALLE_CM 4 //Nombre max de groupes de TP dans une même salle CM
	#define CAPACITE_SALLE_TD 2
	#define CAPACITE_SALLE_LANG 2
	#define CAPACITE_SALLE_INFO 2
	#define CAPACITE_SALLE_LABO 2

	#define NB_SALLE_CM 2 		//(160 places) : pour la L0 les TD se font en CM également 
	#define NB_SALLE_TD 5		//(40 places)
	#define NB_SALLE_LANG 7		//(20 places)
	#define NB_SALLE_INFO 2		//(20 places)
	#define NB_SALLE_LABO 2		//(20 places)

	#define NB_SALLES 18     //NB_SALLE_CM + NB_SALLE_TD + NB_SALLE_LANG + NB_SALLE_INFO + NB_SALLE_LABO;

	#define PROF_VACATAIRE 0	//Prof vacataire
	#define PROF_PLEIN_TEMPS 1	//Prof à plein temps
	#define PROF_MI_TEMPS 2		//Prof à mi-temps

	#define NB_PROF_MATH 3		//Nombre de profs de math
	#define NB_PROF_PHYSIQUE 4	//Nombre de profs de physique
	#define NB_PROF_INFO 4		//Nombre de profs de info
	#define NB_PROF_CHIMIE 4	//Nombre de profs de chimie
	#define NB_PROF_ANGLAIS 4	//Nombre de profs de anglais
	#define NB_PROF_FRANCAIS 5	//Nombre de profs de francais
	
	#define NB_PROFS 24 //NB_PROF_MATH + NB_PROF_PHYSIQUE + NB_PROF_INFO + NB_PROF_CHIMIE + NB_PROF_ANGLAIS + NB_PROF_FRANCAIS

	#define NB_GROUPES_L0 8 	//Nombre de groupes de TP en L0
	#define NB_GROUPES_CE 2		//Nombre de groupes de TP en L1 Chemical Engineering
	#define NB_GROUPES_CS 2		//Nombre de groupes de TP en L1 Computer Science
	#define NB_GROUPES_GE 2		//Nombre de groupes de TP en L1 Geophysical Engineering
	#define NB_GROUPES_OG 2		//Nombre de groupes de TP en L1 Oil and Gas
	// Nombre de groupes de TP de 20 élèves
	#define NB_GROUPES 16 	//NB_GROUPES_L0 + NB_GROUPES_CE +	NB_GROUPES_CS + NB_GROUPES_GE + NB_GROUPES_OG;
	#define NB_GROUPES_L1 8 //NB_GROUPES - NB_GROUPES_L0

	#define MAX_GROUPES_SALLES 4 //nombre de groupes max dans une même salles

	//type de profs
	#define PROF_MATH 0
	#define PROF_PHYSIQUE 1
	#define PROF_INFO 2
	#define PROF_CHIMIE 3
	#define PROF_ANGLAIS 4
	#define PROF_FRANCAIS 5

	#define NB_HEURES_PLEIN_TEMPS 384
	#define NB_HEURES_MI_TEMPS 192
	#define NB_HEURES_VACATAIRE 0

	//on regroupe les cours par type
	#define COURS_LIBRE -1
	#define COURS_MATH 0
	#define COURS_PHYSIQUE 1
	#define COURS_INFO 2
	#define COURS_ANGLAIS 3
	#define COURS_FRANCAIS 4
	#define COURS_CHIMIE 5
	#define COURS_AUTRE 6 //on considère que tous les profs peuvent enseigner ce cours
	#define NB_MATIERES 7 //nombre de matiere non-libre

	//type des cours (dois correspondre aux index des tableaux représentant les nombre d'heures de cours)
	#define COURS_CM 0
	#define COURS_CI 1
	#define COURS_TD 2
	#define COURS_TP 3
	#define NB_TYPES_COURS 4 //CM, CI, TD et TP

	//liste des cours à suivre de tous les groupes / matières / types
	int listeCoursASuivre[] = {
		20, 106, 0, 0,
		14, 70, 0, 21,
		10, 88, 0, 21,
		0, 84, 0, 42,
		0, 112, 0, 42,
		14, 70, 0, 21,
		0, 0, 8, 42,
		60, 0, 84, 0,
		84, 0, 84, 0,
		24, 0, 24, 24,
		0, 72, 0, 36,
		0, 72, 0, 36,
		90, 0, 81, 72,
		6, 6, 0, 6,
		60, 0, 84, 0,
		84, 0, 84, 0,
		99, 0, 84, 81,
		0, 72, 0, 36,
		0, 72, 0, 36,
		0, 0, 0, 0,
		6, 6, 0, 6,
		60, 0, 84, 0,
		84, 60, 84, 0,
		24, 0, 24, 24,
		0, 72, 0, 36,
		0, 72, 0, 36,
		60, 0, 51, 42,
		6, 6, 0, 6,
		75, 0, 90, 9,
		99, 0, 93, 6,
		24, 0, 24, 24,
		0, 72, 0, 36,
		0, 72, 0, 36,
		60, 0, 51, 42,
		6, 6, 0, 6
	};
	#define NB_COURS 12946
	
\end

\User functions:
	void copierCours(Cours* from, Cours* to)
	{
		to->groupe = from->groupe;
		to->matiere = from->matiere;
		to->type = from->type;
		to->prof = from->prof;
		to->salle = from->salle;
		to->creneau = from->creneau;
	}

	inline int getIdxNombreCours(int specialite, int matiere, int type)
	{
		return (((specialite * NB_MATIERES) + matiere) * NB_TYPES_COURS) + type;
	}
	
	inline int getIdxNombreCours(int matiere, int type)
	{
		return (matiere * NB_TYPES_COURS) + type;
	}

	Groupe* instancierGroupe()
	{
		Groupe* g = new Groupe();
		g->specialisation = -1;
		for(int i=0; i<NB_CRENEAUX; ++i)
		{
			g->occupation[i] = 0;
			g->matiere[i] = COURS_LIBRE;
			g->cours[i] = NULL;
		}
		
		for(int i=0; i<NB_MATIERES * NB_TYPES_COURS; ++i)
		{
			g->coursASuivre[i] = 0;
		}
		return g;
	}

	Cours* instancierCours()
	{
		Cours* c = new Cours();
		c->groupe = GROUPE_LIBRE;
		c->matiere = COURS_LIBRE;
		c->type = -1;
		c->prof = -1;
		c->salle = -1;
		c->creneau = -1;
		return c;
	}

	Prof* instancierProf()
	{
		Prof* p = new Prof();
		p->id = 'X';
		p->type = -1;
		p->potentiel = -1;
		p->matiere = COURS_LIBRE;
		for(int i=0; i<NB_CRENEAUX; ++i)
		{
			p->occupation[i] = 0;
			p->groupe[i] = GROUPE_LIBRE;
			p->cours[i] = NULL;
		}
		return p;
	}

	Salle* instancierSalle()
	{
		Salle* s = new Salle();
		s->type = -1;
		s->potentiel = 0;
		for(int i=0; i<NB_CRENEAUX; ++i)
		{
			s->occupation[i] = 0;
		}
		return s;
	}

	Creneau* instancierCreneau()
	{
		Creneau* c = new Creneau();
		c->potentiel = NB_SALLES;
		return c;
	}

	std::string creneauToString(int creneau)
	{
		switch(creneau % 4)
		{
			case 0: return "8H30 - 10H";
			case 1: return "10H15 - 11H45";
			case 2: return "12H45 - 14H15";
			case 3: return "14H30 - 16H";
			default: return "Erreur";
		}
	}

	std::string matiereToString(int matiere)
	{
		switch(matiere)
		{
			case COURS_MATH: return "MATH";
			case COURS_PHYSIQUE: return "PHYSIQUE";
			case COURS_INFO: return "INFO";
			case COURS_CHIMIE: return "CHIMIE";
			case COURS_ANGLAIS: return "ANGLAIS";
			case COURS_FRANCAIS: return "FRANCAIS";
			case COURS_AUTRE: return "AUTRE";
			default: return "ERREUR";
		}
	}

	std::string typeCoursToString(int type)
	{
		switch(type)
		{
			case COURS_CM: return "CM";
			case COURS_CI: return "CI";
			case COURS_TD: return "TD";
			case COURS_TP: return "TP";
			default: return "ERREUR";
		}
	}

	std::string specialisationToString(int spe)
	{
		switch(spe)
		{
			case SPEC_L0: return "L0";
			case SPEC_CE: return "spécialité Chemical Engineering";
			case SPEC_CS: return "spécialité Computer Science";
			case SPEC_GE: return "spécialité Geophysical Engineering";
			case SPEC_OG: return "spécialité Oil and Gas";
			default: return "ERREUR";
		}
	}

	std::string typeSalleToString(int type)
	{
		switch(type)
		{
			case SALLE_CM: return "CM";
			case SALLE_TD: return "TD";
			case SALLE_LABO: return "LABO";
			case SALLE_INFO: return "INFO";
			case SALLE_LANG: return "LANG";
			default: return "ERREUR";
		}
	}
\end

/* -------------------------------------------------------------------------------------------- */

/************************************************************************************************/
/*******************///             DECLARATION DES CLASSES               ///********************/
/************************************************************************************************/
\User classes :

/* Classe représentant un cours. Un cours se compose de chaque élément ci-dessous.		*/
Cours
{
	int		groupe;					/* représente le groupe participant (initialisé à GROUPE_LIBRE si pas de groupe)	*/
	int		matiere;				/* représente une matière		*/
    int		type;					/* type du cours (CM, CI, TD, TP)*/
 	int		prof;					/* représente un prof			*/
	int		salle;					/* représente une salle			*/
	int		creneau;				/* représente un créneau (de 0 à NB_CRENEAUX)	*/
}

/* Classe représentant un groupe de TP de 20 etudiants.					*/
Groupe
{
	int		specialisation;				/* type de diplome */
	int		occupation	[NB_CRENEAUX];	/* indique si présente dans le créneau	*/
	//si matiere[i] == COURS_LIBRE -> pas d'occupation
	int		matiere		[NB_CRENEAUX];	/* indique la matière dans le créneau	*/
	int 	coursASuivre[NB_MATIERES * NB_TYPES_COURS]; /* indique le nombre de cours suivis de chaque matiere et type */
	Cours*  cours[NB_CRENEAUX]; //utilisé uniquement dans display pour simplifier l'affichage
}

/* Classe représentant un enseignant.							*/
Prof
{
	char 	id; //correspond à A,B,C ou D sur le sujet
	int 	type; //prof plein-temps, mi-temps ou vacataire
	int		potentiel;						/* indique son nombre d'horaires	*/
	int		occupation	[NB_CRENEAUX];	/* nombre de cours sur un même creneau */
	int		matiere;						//matiere enseignée par le prof
	int		groupe		[NB_CRENEAUX];		/* indique le group dans le créneau	*/
	Cours*  cours[NB_CRENEAUX]; //utilisé uniquement dans display pour simplifier l'affichage
}

/* Classe représentant une salle de cours.							*/
Salle
{
	int		type;						//type de la salle
	int 	potentiel;
	int		occupation	[NB_CRENEAUX];	/* indique si occupée dans le créneau	*/
}

Creneau
{
	int potentiel; // initialisé à NB_SALLES, si < 0, il y plus de cours qui de salles le même jour au même creneau
}

/* Classe représentant un génome, soit un emplois du temps complet.				*/
GenomeClass
{ 
	Cours*	cours			[NB_COURS];	/* les cours				*/
	Groupe*	groupes			[NB_GROUPES];	/* les groupes TP				*/
	Prof*	profs			[NB_PROFS];	/* les profs				*/
	Salle*	salles			[NB_SALLES];	/* les salles				*/
	Creneau* 	creneaux		[NB_CRENEAUX]; /* les creneaux */
}

\end
/* -------------------------------------------------------------------------------------------- */

\After everything else function:
	//bBest->printOn(std::cout);
	std::string nomFichier = "resultat.txt";
	std::fstream fichier(nomFichier, ios::out);
	if(fichier.good())
	{
		bBest->printOn(fichier);
		fichier << std::endl << "évaluation : " << bBest->evaluate() << std::endl;
		fichier.close();
		std::cout << "Meilleure évaluation : " << bBest->evaluate() << std::endl;
	}
	else
	{
		std::cout << std::endl << "Ouverture du fichier " << nomFichier << " impossible, affichage dans la sortie standard." << std::endl;
		bBest->printOn(std::cout);
		std::cout << std::endl << "évaluation : " << bBest->evaluate() << std::endl;
	}
\end

\GenomeClass::display:
	os << "======================Affichage des salles======================" << std::endl << std::endl;

	for(int i=0; i<NB_SALLES; ++i)
	{
		os << "Salle " << i << " : " << typeSalleToString(Genome.salles[i]->type) << std::endl;
	}

	os << std::endl << "======================Affichage des groupes======================" << std::endl << std::endl;

	for(int i=0; i<NB_GROUPES; ++i)
	{
		os << "Groupe TP " << i << " : " << specialisationToString(Genome.groupes[i]->specialisation) << std::endl;
	}

	os << std::endl << "======================Affichage des emplois du temps des profs======================" << std::endl << std::endl;

	int compteurJours;
	std::string indent = "    ";
	Prof* p;
	Cours* c;
	//Pour simplifier l'affichage
	for(int i=0; i<NB_COURS; ++i)
	{
		Genome.groupes[Genome.cours[i]->groupe]->cours[Genome.cours[i]->creneau] = Genome.cours[i];
		Genome.profs[Genome.cours[i]->prof]->cours[Genome.cours[i]->creneau] = Genome.cours[i];
	}

	for(int i=0; i<NB_PROFS; ++i)
	{
		p = Genome.profs[i];
		os << "----------" << "prof " << p->id << "(" << matiereToString(p->matiere) << ")----------" << std::endl << std::endl;
		compteurJours = 0;
		for(int j=0; j<NB_CRENEAUX; j++)
		{
			if(j % 4 == 0)
			{
				compteurJours++;
				os << "Jour " << compteurJours << ":" << std::endl;
			}
			c = p->cours[j];
			if(c == NULL)
			{
				os << indent << creneauToString(j) << " : LIBRE" << std::endl;
			}
			else
			{
				os << indent << creneauToString(j) << " : groupe TP " << c->groupe << " -> " << matiereToString(c->matiere);
				os << "(" << typeCoursToString(c->type) << "), salle " << c->salle << "(" << typeSalleToString(Genome.salles[c->salle]->type) << ")" << std::endl;
			}
		}
	}

	os << std::endl << "======================Affichage des emplois du temps des groupes de TP======================" << std::endl << std::endl;

	Groupe* g;
	for(int i=0; i<NB_GROUPES; ++i)
	{
		g = Genome.groupes[i];
		os << "----------" << "Groupe TP " << i << " : " << specialisationToString(g->specialisation) << "----------" << std::endl << std::endl;
		compteurJours = 0;
		for(int j=0; j<NB_CRENEAUX; j++)
		{
			if(j % 4 == 0)
			{
				compteurJours++;
				os << "Jour " << compteurJours << ":" << std::endl;
			}
			c = g->cours[j];
			if(c == NULL)
			{
				os << indent << creneauToString(j) << " : LIBRE" << std::endl;
			}
			else
			{
				os << indent << creneauToString(j) << " : prof " << Genome.profs[c->prof]->id << " -> " << matiereToString(c->matiere);
				os << "(" << typeCoursToString(c->type) << "), salle " << c->salle << "(" << typeSalleToString(Genome.salles[c->salle]->type) << ")" << std::endl;
			}
		}
	}

\end

\GenomeClass::initialiser:
	//initialisation des groupes de TP
	int compteur = 0;
	Groupe* g;
	int nbCours;
	for(int i=0; i<NB_GROUPES; ++i) 
	{
		g = instancierGroupe();
		if(i<NB_GROUPES_L0)
		{
			g->specialisation = SPEC_L0;
		}
		else if(i<NB_GROUPES_L0 + NB_GROUPES_CE)
		{
			g->specialisation = SPEC_CE;
		}
		else if(i<NB_GROUPES_L0 + NB_GROUPES_CE + NB_GROUPES_CS)
		{
			g->specialisation = SPEC_CS;
		}
		else if(i < NB_GROUPES_L0 + NB_GROUPES_CE + NB_GROUPES_CS + NB_GROUPES_GE)
		{
			g->specialisation = SPEC_GE;
		}
		else
		{
			g->specialisation = SPEC_OG;
		}
		
		for(int j=0; j<NB_MATIERES; ++j) //matiere
		{
			for(int k=0; k<NB_TYPES_COURS; ++k) //type
			{
				nbCours = listeCoursASuivre[getIdxNombreCours(g->specialisation, j, k)];
				g->coursASuivre[getIdxNombreCours(j, k)] = nbCours;
				for(int l=0; l<nbCours; l++)
				{
					Genome.cours[compteur] = instancierCours();
					Genome.cours[compteur]->matiere = j;
					Genome.cours[compteur]->type = k;
					Genome.cours[compteur]->groupe = i;
					compteur++;
				}
			}
		}
		Genome.groupes[i] = g;
	}
	
	if(compteur != NB_COURS)
	{
		std::cerr << "Erreur : nombre d'instanciation incorrect (" << compteur << ")" << std::endl;
		exit(EXIT_FAILURE);
	}

	//initialisation des profs
	compteur = 0;
	for(int i=0; i<NB_PROF_MATH; ++i) 
	{
		Genome.profs[compteur] = instancierProf();
		Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
			Genome.profs[compteur]->potentiel = NB_HEURES_PLEIN_TEMPS;
		Genome.profs[compteur]->matiere = PROF_MATH;
		Genome.profs[compteur]->id = (char)('A' + i);
		compteur++;
	}
	for(int i=0; i<NB_PROF_PHYSIQUE; ++i) 
	{
		Genome.profs[compteur] = instancierProf();
		Genome.profs[compteur]->matiere = PROF_PHYSIQUE;
		Genome.profs[compteur]->id = (char)('A' + i);
		if(i < 2)
		{
			Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
			Genome.profs[compteur]->potentiel = NB_HEURES_PLEIN_TEMPS;
		}
		else if(i == 3)
		{
			Genome.profs[compteur]->type = PROF_MI_TEMPS;
			Genome.profs[compteur]->potentiel = NB_HEURES_MI_TEMPS;
		}
		else
		{
			Genome.profs[compteur]->type = PROF_VACATAIRE;
			Genome.profs[compteur]->potentiel = NB_HEURES_VACATAIRE;
		}
		compteur++;
	}
	for(int i=0; i<NB_PROF_INFO; ++i) 
	{
		Genome.profs[compteur] = instancierProf();
		Genome.profs[compteur]->matiere = PROF_INFO;
		Genome.profs[compteur]->id = (char)('A' + i);
		if(i < 2)
		{
			Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
			Genome.profs[compteur]->potentiel = NB_HEURES_PLEIN_TEMPS;
		}
		else if(i == 3)
		{
			Genome.profs[compteur]->type = PROF_MI_TEMPS;
			Genome.profs[compteur]->potentiel = NB_HEURES_MI_TEMPS;
		}
		else
		{
			Genome.profs[compteur]->type = PROF_VACATAIRE;
			Genome.profs[compteur]->potentiel = NB_HEURES_VACATAIRE;
		}
		compteur++;
	}
	for(int i=0; i<NB_PROF_CHIMIE; ++i) 
	{
		Genome.profs[compteur] = instancierProf();
		Genome.profs[compteur]->matiere = PROF_CHIMIE;
		Genome.profs[compteur]->id = (char)('A' + i);
		if(i < 2)
		{
			Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
			Genome.profs[compteur]->potentiel = NB_HEURES_PLEIN_TEMPS;
		}
		else
		{
			Genome.profs[compteur]->type = PROF_MI_TEMPS;
			Genome.profs[compteur]->potentiel = NB_HEURES_MI_TEMPS;
		}
		compteur++;
	}
	for(int i=0; i<NB_PROF_ANGLAIS; ++i) 
	{
		Genome.profs[compteur] = instancierProf();
		Genome.profs[compteur]->matiere = PROF_ANGLAIS;
		Genome.profs[compteur]->id = (char)('A' + i);
		Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
		Genome.profs[compteur]->potentiel = NB_HEURES_PLEIN_TEMPS;
		compteur++;
	}
	for(int i=0; i<NB_PROF_FRANCAIS; ++i) 
	{
		Genome.profs[compteur] = instancierProf();
		Genome.profs[compteur]->matiere = PROF_FRANCAIS;
		Genome.profs[compteur]->id = (char)('A' + i);
		if(i < 2)
		{
			Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
			Genome.profs[compteur]->potentiel = NB_HEURES_PLEIN_TEMPS;
		}
		else if(i < 4)
		{
			Genome.profs[compteur]->type = PROF_MI_TEMPS;
			Genome.profs[compteur]->potentiel = NB_HEURES_MI_TEMPS;
		}
		else
		{
			Genome.profs[compteur]->type = PROF_VACATAIRE;
			Genome.profs[compteur]->potentiel = NB_HEURES_VACATAIRE;
		}
		compteur++;
	}

	//initialisation des salles

	for(int i=0; i<NB_SALLES; ++i)
	{
		Genome.salles[i]			= instancierSalle();
		if(i<2)
		{
			Genome.salles[i]->type			= SALLE_CM;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_CM;
		}
		else if(i < 7)
		{
			Genome.salles[i]->type			= SALLE_TD;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_TD;
		}
		else if(i < 14)
		{
			Genome.salles[i]->type			= SALLE_LANG;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_LANG;
		}
		else if(i < 16)
		{
			Genome.salles[i]->type			= SALLE_INFO;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_INFO;
		}
		else
		{
			Genome.salles[i]->type			= SALLE_LABO;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_LABO;
		}
	}

	//initialisation des creneaux
	for(int i=0; i<NB_CRENEAUX; ++i) 
	{
		Genome.creneaux[i] = instancierCreneau();
	}

	//initialisation des cours
	int r, j, tries, limit, typeSalle;
	Prof* p;
	Salle* s;
	for(int i=0; i<NB_COURS; ++i) 
	{
		g = Genome.groupes[Genome.cours[i]->groupe];
		tries = 0;
		do
		{
			//on cherche une créneau aléatoire ayant au moins une salle de libre quelle qu'elle soit
			r = random(0, NB_CRENEAUX);
			tries++;
		}while(Genome.creneaux[r]->potentiel <= 0  && g->occupation[Genome.cours[i]->creneau] > 0 && tries < NB_CRENEAUX);
		Genome.cours[i]->creneau  = r;
		Genome.creneaux[Genome.cours[i]->creneau]->potentiel--;
		g->occupation[Genome.cours[i]->creneau]++;

		//dans les autre cas on prend au hasard un prof libre pouvant enseigné la matière
		if((Genome.cours[i]->matiere == COURS_FRANCAIS || Genome.cours[i]->matiere == COURS_ANGLAIS) && Genome.cours[i]->type != COURS_CM)
		{
			limit = NB_SALLE_LANG;
			typeSalle = SALLE_LANG;
		}
		else
		{
			switch(Genome.cours[i]->type)
			{
				case COURS_CM:
					limit = NB_SALLE_CM;
					typeSalle = SALLE_CM;
					break;
				case COURS_CI:
				case COURS_TD:
					limit = NB_SALLE_TD;
					typeSalle = SALLE_TD;
					break;
				case COURS_TP:
					switch(Genome.cours[i]->matiere)
					{
						case COURS_PHYSIQUE:
						case COURS_CHIMIE:
							limit = NB_SALLE_LABO;
							typeSalle = SALLE_LABO;
							break;
						case COURS_INFO:
							limit = NB_SALLE_INFO;
							typeSalle = SALLE_INFO;
							break;
						default:
							limit = 0;
							typeSalle = -1;
					}
					break;
				default:
					limit = 0;
					typeSalle = -1;
			}
		}
		if(typeSalle < 0)
		{
			tries = 0;
			do
			{
				r = random(0, NB_SALLES);
				s = Genome.salles[r];
				tries++;
			}while(s->occupation[Genome.cours[i]->creneau] >= s->potentiel && tries < NB_SALLES);
			Genome.cours[i]->salle = r;
			s->occupation[Genome.cours[i]->creneau]++;
		}
		else
		{
			j=0;
			while(Genome.salles[j]->type != typeSalle)
			{
				j++;
			}
			tries = 0;
			do
			{
				r = random(0, limit);
				s = Genome.salles[j + r];
				tries++;
			}while(s->occupation[Genome.cours[i]->creneau] >= s->potentiel && tries < NB_SALLES);
			Genome.cours[i]->salle = j + r;
			s->occupation[Genome.cours[i]->creneau]++;
		}

		if(Genome.cours[i]->matiere == COURS_AUTRE)
		{
			//n'importe quel prof libre peut enseigner les cours qualifiés comme 'autre'
			tries = 0;
			do
			{
				r = random(0, NB_PROFS);
				tries++;
			}while(Genome.profs[r]->occupation[Genome.cours[i]->creneau] > 0 && tries < NB_PROFS);
			Genome.cours[i]->prof = r;
			Genome.profs[r]->occupation[Genome.cours[i]->creneau]++;
		}
		else
		{
			//dans les autre cas on prend au hasard un prof libre pouvant enseigné la matière
			switch(Genome.cours[i]->matiere)
			{
				case COURS_MATH: limit = NB_PROF_MATH; break;
				case COURS_INFO: limit = NB_PROF_INFO; break;
				case COURS_PHYSIQUE: limit = NB_PROF_PHYSIQUE; break;
				case COURS_CHIMIE: limit = NB_PROF_CHIMIE; break;
				case COURS_FRANCAIS: limit = NB_PROF_FRANCAIS; break;
				case COURS_ANGLAIS: limit = NB_PROF_ANGLAIS; break;
				default: limit = 0;
			}
			j=0;
			while(Genome.profs[j]->matiere != Genome.cours[i]->matiere)
			{
				j++;
			}
			tries = 0;
			do
			{
				r = random(0, limit);
				p = Genome.profs[j + r];
				tries++;
			}while(p->occupation[Genome.cours[i]->creneau] > 0 && (p->type == PROF_VACATAIRE || p->potentiel > 0) && tries < NB_PROFS);
			Genome.cours[i]->prof = j + r;
			p->occupation[Genome.cours[i]->creneau]++;
			p->potentiel--;
		}
	}
\end

\GenomeClass::crossover:
	//pour chaque cours, 1 chance sur 2 de garder le creneau du parent2
	//si le cours est dans une salle appropriée
	int matiere, salle, type;
	Salle* s;
	for (int i=0; i<NB_COURS; ++i)
	{
		matiere = parent2.cours[i]->matiere;
		salle = parent2.cours[i]->salle;
		type = parent2.cours[i]->type;
		s = parent2.salles[salle];
		switch(type)
		{
			case COURS_CM:
				if(s->type == SALLE_CM)
				{
					copierCours(parent2.cours[i], child.cours[i]);
				}
				break;
			case COURS_CI:
			case COURS_TD:
				if(s->type == SALLE_TD)
				{
					copierCours(parent2.cours[i], child.cours[i]);
				}
				break;
			case COURS_TP:
				switch(matiere)
				{
					case COURS_INFO:
						if(s->type == SALLE_INFO)
						{
							copierCours(parent2.cours[i], child.cours[i]);
						}
					case COURS_PHYSIQUE:
					case COURS_CHIMIE:
						if(s->type == SALLE_LABO)
						{
							copierCours(parent2.cours[i], child.cours[i]);
						}
						break;
					case COURS_FRANCAIS:
					case COURS_ANGLAIS:
						if(s->type == SALLE_LANG)
						{
							copierCours(parent2.cours[i], child.cours[i]);
						}
						break;
					default:;
				}
				break;
			default:;
		}
	}
\end

\GenomeClass::mutator:
	int	nb = 0;

	/* -------------------------------------------------------------------------------------------- */
	/* EVALUATION DES CRENEAUX									*/
	/* -------------------------------------------------------------------------------------------- */

	/* Initialisation des compteurs 								*/
	for (int k=0; k<NB_GROUPES; ++k)
	{
		for(int j=0; j<NB_CRENEAUX; ++j)
		{
			Genome.groupes[k]->occupation[j] = 0;
		}
	}

	for (int k=0; k<NB_PROFS; ++k)
	{
		for(int j=0; j<NB_CRENEAUX; ++j)
		{
			Genome.profs[k]->occupation[j] = COURS_LIBRE;
		}
	}

	for (int k=0; k<NB_SALLES; ++k)
	{
		for(int j=0; j<NB_CRENEAUX; ++j)
		{
			Genome.salles[k]->occupation[j]	= COURS_LIBRE;
		}
	}

	for (int j=0; j<NB_CRENEAUX; ++j)
	{
		Genome.creneaux[j]->potentiel = NB_SALLES;
	}

	/* Affectation des compteurs 									*/
	for (int i=0; i<NB_COURS; ++i)
	{
		int j = Genome.cours[i]->creneau;
		Genome.groupes[Genome.cours[i]->groupe]->occupation[j]++;
		Genome.profs[Genome.cours[i]->prof]	->occupation[j]++;
		Genome.salles[Genome.cours[i]->salle]->occupation[j]++;
		Genome.creneaux[j]->potentiel--;
	}


	/* Analyse & Modification des compteurs 							*/
	for (int i=0; i<NB_COURS; ++i)
	{
		int	j= Genome.cours[i]->creneau;
		int	c= Genome.cours[i]->groupe;
		int	p= Genome.cours[i]->prof;
		int	s= Genome.cours[i]->salle;
		int	err	= 0;
		int	r= j;
			
	/* en cas de mutation, on échange deux profs de même matière					*/
	/*
		if (sigmaP < pMutPerGene)
		{
			int k		= 0;
			int minprof	= 0;
			int maxprof	= nbProfsTx[k];
			int y		= 0;
				
			while (p > maxprof)
			{
				minprof = maxprof;
				maxprof += nbProfsTx[++k];
			}
				
			if (p == maxprof)
			{
				y = minprof;
			}
			else
			{
				y = p+1;
			}
				
			for (int x=0; x<NB_COURS; ++x)
			{
				if (Genome.cours[x]->prof == y)
				{
					Genome.cours[x]->prof = p;
					Genome.profs	[p]	->occupation[Genome.cours[x]->creneau]++;
					Genome.profs	[y]	->occupation[Genome.cours[x]->creneau]--;
					Genome.cours[i]->prof = y;
					Genome.profs	[y]	->occupation[j]++;
					Genome.profs	[p]	->occupation[j]--;
					break;
				}
			}
		}
		*/

	/* on vérifie l'occupation des éléments du cours 						*/
		
		if (err == 0)
		{
			if (Genome.groupes[c]->occupation[j] > 1)
			{
				err = 1;
			}
			if (Genome.profs[p]->occupation[j] > 1)
			{
				err = 2;
			}
			if (Genome.salles[s]->occupation[j] > 1)
			{
				err = 3;
			}
		}

	/* en cas d'erreur, on "corrige" le cours en le réinitialisant de manière valide.		*/
		if (err > 0)
		{
			nb++;
			r 	= j;
			int mode = 1;
			do
			{
				r = (r + 1)%NB_CRENEAUX;
				if (r == j)
				{
					if (mode == 2)
					{
						break;
					}
					else
					{
						mode++;
					}
				}
			}
			while
			(
				(Genome.creneaux[r]->potentiel <= 0) ||
				(
					((Genome.creneaux[r]->potentiel == NB_SALLES) && (mode < 2)) ||
					(Genome.groupes	[c]	->occupation[r] > 0) ||
					(Genome.profs	[p]	->occupation[r] > 0) ||
					(Genome.salles	[s]	->occupation[r] > 0)
				)
			);
			
			Genome.groupes	[c]	->occupation[j]--;
			Genome.profs	[p]	->occupation[j]--;
			Genome.salles	[s]	->occupation[j]--;
			Genome.creneaux	[j]	->potentiel++;
			
			Genome.groupes	[c]	->occupation[r]++;
			Genome.profs	[p]	->occupation[r]++;
			Genome.salles	[s]	->occupation[r]++;
			Genome.creneaux	[r]	->potentiel--;
		}

		Genome.cours[i]->creneau = r;
	}

	return nb;
\end

\GenomeClass::evaluator:
	int evaluation = 0;

	//initialisation des compteurs à des valeurs par défaut
	for(int i=0; i<NB_GROUPES; ++i)
	{
		for(int j=0; j<NB_CRENEAUX; ++j)
		{
			Genome.groupes[i]->occupation[j] = 0;
			Genome.groupes[i]->matiere[j] = COURS_LIBRE;
		}
	}

	for(int i=0; i<NB_PROFS; ++i)
	{
		switch(Genome.profs[i]->type)
		{
			case PROF_PLEIN_TEMPS:
				Genome.profs[i]->potentiel = NB_HEURES_PLEIN_TEMPS;
				break;
			case PROF_MI_TEMPS:
				Genome.profs[i]->potentiel = NB_HEURES_MI_TEMPS;
				break;
			default:
				Genome.profs[i]->potentiel = NB_HEURES_VACATAIRE;
		}
		for(int j=0; j<NB_CRENEAUX; ++j)
		{
			Genome.profs[i]->occupation[j] = 0;
			Genome.profs[i]->groupe[j] = COURS_LIBRE;
		} 
	}

	for(int i=0; i<NB_SALLES; ++i)
	{
		for(int j=0; j<NB_CRENEAUX; ++j)
		{
			Genome.salles[i]->occupation[j] = 0;
		} 
	}

	for(int i=0; i<NB_CRENEAUX; ++i)
	{
		Genome.creneaux[i]->potentiel = NB_SALLES;
	}

	int creneau, groupe, prof, matiere, type;
	Cours* c;
	for(int i=0; i<NB_COURS; ++i)
	{
		c = Genome.cours[i];
		//Creneau du cours
		creneau = c->creneau;
		//groupe du cours
		groupe = c->groupe;
		//prof du cours
		prof = c->prof;
		//matiere du cours
		matiere = c->matiere;
		//type du cours
		type = c->type;

		//Le groupe du cours est occupé pour ce créneau
		Genome.groupes[groupe]->occupation[creneau]++;
		//La matiere que suit le groupe à ce creneau est celle du cours
		Genome.groupes[groupe]->matiere[creneau] = matiere;
		//Le groupes suis un cours supplémentaire
		Genome.groupes[groupe]->coursASuivre[getIdxNombreCours(matiere, type)]--;

		//Le prof du cours est occupé pour ce créneau
		Genome.profs[prof]->occupation[creneau]++;
		//Le prof enseigne au groupe de ce cours
		Genome.profs[prof]->groupe[creneau] = groupe;
		//Le prof travail une heure
		Genome.profs[prof]->potentiel--;

		//La salle est occupé par un groupe
		Genome.salles[c->salle]->occupation[creneau]++;
		//Le contient un cours supplémentaire
		Genome.creneaux[creneau]->potentiel--;
	}

	for(int i=0; i<NB_GROUPES; ++i)
	{
		for(int j=0; j<NB_MATIERES; ++j)
		{
			for(int k=0; k<NB_TYPES_COURS; ++k)
			{
				if(Genome.groupes[i]->coursASuivre[getIdxNombreCours(j, k)] != 0)
				{
					//Mauvais nombre d'heures suivis
					evaluation += PENALITE_FORTE;
				}
			}
		}
	}

	//Évaluation des occupations pour les groupes, les profs, les salles et les creneaux
	int compteurCoursGroupe = 0, compteurCoursProf = 0;
	for(int i=0; i<NB_CRENEAUX; ++i)
	{
		for(int j=0; j<NB_GROUPES; ++j)
		{
			if(Genome.groupes[j]->matiere[i] != COURS_LIBRE)
			{
				compteurCoursGroupe++;
			}
			if(Genome.groupes[j]->occupation[i] > 1)
			{
				//plus d'un cours en même temps 
				evaluation += PENALITE_OBLIGATOIRE;
			}
		}

		for(int j=0; j<NB_PROFS; ++j)
		{
			if(Genome.profs[j]->occupation[i] > 1)
			{
				//plus d'un cours en même temps 
				evaluation += PENALITE_OBLIGATOIRE;
				compteurCoursProf++;
			}
		}

		if(i % NB_CRENEAUX_JOUR == 0)
		{
			if(compteurCoursGroupe == 1 || compteurCoursGroupe == NB_CRENEAUX_JOUR)
			{
				//Un seul cours, ou journée complète
				evaluation += PENALITE_FORTE;
			}
			if(compteurCoursProf == 1 || compteurCoursProf == NB_CRENEAUX_JOUR)
			{
				//Un seul cours, ou journée complète
				evaluation += PENALITE_FORTE;
			}
			compteurCoursGroupe = 0;
			compteurCoursProf = 0;
		}

		for(int j=0; j<NB_SALLES; ++j)
		{
			if(Genome.salles[j]->occupation[i] > Genome.salles[j]->potentiel)
			{
				//plus de groupes que possible dans la salle
				evaluation += PENALITE_OBLIGATOIRE;
			}
		}

		if(Genome.creneaux[i]->potentiel < 0)
		{
			//plus de cours que dans salle
			evaluation += PENALITE_OBLIGATOIRE;
		}
	}

	//Évaluation des horaires effectués par les profs
	for(int j=0; j<NB_PROFS; ++j)
	{
		if(Genome.profs[j]->potentiel < 0)
		{
			if(Genome.profs[j]->type == PROF_VACATAIRE)
			{
				//Moins on doit payer de vacataire, mieux c'est
				evaluation += PENALITE_FAIBLE * -Genome.profs[j]->potentiel;
			}
			else
			{
				//On suppose que les heures supps ne sont pas tolérables
				evaluation += PENALITE_OBLIGATOIRE;
			}
		}
	}

	Salle* s;
	Prof* p;
	for(int i=0; i<NB_COURS; ++i)
	{
		c = Genome.cours[i];
		s = Genome.salles[c->salle];
		p = Genome.profs[c->prof];

		//Évaluation matiere / prof
		if(c->matiere != COURS_AUTRE && c->matiere != COURS_LIBRE && p->matiere != c->matiere)
		{
			//Si le prof ne peut pas enseigner cette matiere
			evaluation += PENALITE_OBLIGATOIRE;
		}

		//Évaluation des types de salle pour chaque cours
		switch(c->type)
		{
			case COURS_CM:
				if(s->type != SALLE_CM)
				{
					evaluation += PENALITE_FORTE;
				}
				break;
			case COURS_CI:
			case COURS_TD:
			 	//on considère que les CI se passent dans les salles de TD
				if(s->type != SALLE_TD)
				{
					evaluation += PENALITE_FORTE;
				}
				break;
			case COURS_TP:
				switch(c->matiere)
				{
					case COURS_INFO:
						if(s->type != SALLE_INFO)
						{
							evaluation += PENALITE_FORTE;
						}
						break;
					case COURS_ANGLAIS:
					case COURS_FRANCAIS:
						if(s->type != SALLE_LANG)
						{
							evaluation += PENALITE_FORTE;
						}
						break;
					case COURS_CHIMIE:
					case COURS_PHYSIQUE:
						if(s->type != SALLE_LABO)
						{
							evaluation += PENALITE_FORTE;
						}
						break;
					default:
						evaluation += PENALITE_FORTE;
				}
				break;
			default:;
		}
	}

	//pénalités faibles si plusieurs même cours dans une même journée par groupe
	for(int i=0; i<NB_GROUPES; ++i)
	{
		int compteursPlusCours = 0;
		for(int j=0; j<NB_CRENEAUX; j= j+NB_CRENEAUX_JOUR){
			for(int k=0; k<(NB_CRENEAUX_JOUR-1); ++k){
				if(Genome.groupes[i]->matiere[j+k] == Genome.groupes[i]->matiere[j+k+1]){
					compteursPlusCours++;
				}
			}
			if(compteursPlusCours > 1){
				evaluation += PENALITE_FAIBLE;
			}
			compteursPlusCours = 0;
		}
		
	}
	//pénalités faibles par trou dans une journée travaillée
	for(int i=0; i<NB_PROFS; ++i)
	{
		int compteursTrou = 0;
		for(int j=0; j<NB_CRENEAUX; j+=NB_CRENEAUX_JOUR){
			for(int k=0; k<(NB_CRENEAUX_JOUR-1); ++k){
				if(Genome.profs[i]->occupation[j+k] != COURS_LIBRE){
					if(Genome.profs[i]->occupation[j+k+1] == COURS_LIBRE){
						compteursTrou++;
					}
				}
			}
			if(compteursTrou > 0){
				evaluation += PENALITE_FAIBLE;
			}
			compteursTrou = 0;
		}
		
	}

	return evaluation;
\end

\User Makefile options:
	CXXFLAGS+=-std=c++11
\end

\Default run parameters :
  Number of generations : 30
  Time limit: 120
  Population size : 20
  Offspring size : 40%
  Mutation probability : 0.5
  Crossover probability : 0.5
  Evaluator goal : Minimise
  Selection operator: Tournament 2.0
  Surviving parents: 90%
  Surviving offspring: 90%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong
  Elite: 1
  Print stats: true
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:false

  Remote island model: false
  Migration probability: 0

  Save population: false
  Start from file:false
\end