/*________________________________________________________________________________________________
Projet de recherche stochastique : Université de Strasbourg (2017-2018) M1 ILC
Brossard Florian
Dvornichenko Kateryna
Création d'un emplois du temps
________________________________________________________________________________________________*/

\User declarations:
	#include <string>
	#include <cstring>
	#include <iostream>

	#define PENALITE_OBLIGATOIRE 	10000
	#define PENALITE_FORTE			1000
	#define PENALITE_FAIBLE			1

	//Jours de la semaine
	#define JOUR_LUNDI 0
	#define JOUR_MARDI 1
	#define JOUR_MERCREDI 2
	#define JOUR_JEUDI 3
	#define JOUR_VENDREDI 4

	#define NB_JOURS 180 //52 semaines avec 5 jours d'écoles - 16 semaines de vacances
	#define NB_CRENEAUX_JOUR 4 		// 4 creneaux par jours
	const int NB_CRENEAUX = NB_JOURS * NB_CRENEAUX_JOUR;

	#define GROUPE_LIBRE -1		// Pour indiquer l'absence de groupe
	#define SPEC_L0 0			// Pas de spécialisation en L0
	#define SPEC_CE	1			// Chemical Engineering
	#define SPEC_CS	2			// Computer Science
	#define SPEC_GE	3			// Geophysical Engineering
	#define SPEC_OG	4			// Oil and Gas

	#define SALLE_CM 0			//Salle CM
	#define SALLE_TD 1			//Salle TD
	#define SALLE_LANG 2		//Salle langue
	#define SALLE_INFO 3		//Salle info
	#define SALLE_LABO 4		//Salle physique-chimie

	#define CAPACITE_SALLE_CM 4 //Nombre max de groupes de TP dans une même salle CM
	#define CAPACITE_SALLE_TD 2
	#define CAPACITE_SALLE_LANG 2
	#define CAPACITE_SALLE_INFO 2
	#define CAPACITE_SALLE_LABO 2

	#define NB_SALLE_CM 2 		//(160 places) : pour la L0 les TD se font en CM également 
	#define NB_SALLE_TD 5		//(40 places)
	#define NB_SALLE_LANG 7		//(20 places)
	#define NB_SALLE_INFO 2		//(20 places)
	#define NB_SALLE_LABO 2		//(20 places)

	const int NB_SALLES =     NB_SALLE_CM + NB_SALLE_TD
							+ NB_SALLE_LANG + NB_SALLE_INFO
							+ NB_SALLE_LABO;

	#define PROF_VACATAIRE 0	//Prof vacataire
	#define PROF_PLEIN_TEMPS 1	//Prof à plein temps
	#define PROF_MI_TEMPS 2		//Prof à mi-temps

	#define NB_PROF_MATH 3		//Nombre de profs de math
	#define NB_PROF_PHYSIQUE 4	//Nombre de profs de physique
	#define NB_PROF_INFO 4		//Nombre de profs de info
	#define NB_PROF_CHIMIE 4	//Nombre de profs de chimie
	#define NB_PROF_ANGLAIS 4	//Nombre de profs de anglais
	#define NB_PROF_FRANCAIS 5	//Nombre de profs de francais
	
	const int NB_PROFS = NB_PROF_MATH + NB_PROF_PHYSIQUE + NB_PROF_INFO
						 + NB_PROF_CHIMIE + NB_PROF_ANGLAIS + NB_PROF_FRANCAIS;

	#define NB_GROUPES_L0 8 	//Nombre de groupes de TP en L0
	#define NB_GROUPES_CE 2		//Nombre de groupes de TP en L1 Chemical Engineering
	#define NB_GROUPES_CS 2		//Nombre de groupes de TP en L1 Computer Science
	#define NB_GROUPES_GE 2		//Nombre de groupes de TP en L1 Geophysical Engineering
	#define NB_GROUPES_OG 2		//Nombre de groupes de TP en L1 Oil and Gas
	// Nombre de groupes de TP de 20 élèves
	const int NB_GROUPES =  NB_GROUPES_L0 + NB_GROUPES_CE +	NB_GROUPES_CS
							+ NB_GROUPES_GE + NB_GROUPES_OG;
	const int NB_GROUPES_L1 = NB_GROUPES - NB_GROUPES_L0;

	#define MAX_GROUPES_SALLES 4 //nombre de groupes max dans une même salle

	#define NB_COURS 5 			// Nombres de groupes de cours dans l'année

	//type de profs
	#define PROF_MATH 0
	#define PROF_PHYSIQUE 1
	#define PROF_INFO 2
	#define PROF_CHIMIE 3
	#define PROF_ANGLAIS 4
	#define PROF_FRANCAIS 5

	#define NB_HEURES_PLEIN_TEMPS 384
	#define NB_HEURES_MI_TEMPS 192
	#define NB_HEURES_VACATAIRE 0
	
	#define TYPE_COURS 4 //CM, CI, TD et TP

	//on regroupe les cours par type
	#define COURS_LIBRE -1
	#define COURS_MATH 0
	#define COURS_PHYSIQUE 1
	#define COURS_INFO 2
	#define COURS_CHIMIE 3
	#define COURS_ANGLAIS 4
	#define COURS_FRANCAIS 5
	#define NB_MATIERES 6 //nombre de matiere non-libre

	//type des cours (dois correspondre aux index des tableaux représentant les nombre d'heures de cours)
	#define COURS_CM 0
	#define COURS_CI 1
	#define COURS_TD 2
	#define COURS_TP 3
	#define NB_TYPES_COURS 4
	
	//Cours L0
	//S1
	const int NB_S1_MATH[] = {0, 42, 0, 0}; //0 CM, 42 CI, 0 TD, 0 TP 
	const int NB_S1_PHYS[] = {0, 42, 0, 0}; 
	const int NB_S1_CHIM[] = {0, 42, 0, 0}; 
	const int NB_S1_INFO[] = {0, 56, 0, 0}; 
	const int NB_S1_FRANCAIS[] = {0, 42, 0, 42}; 
	const int NB_S1_ANGLAIS[] = {0, 70, 0, 42}; 
	const int NB_S1_OTHER[] = {0, 0, 0, 14};  //methode
	
	//S2
	const int NB_S2_MATH[] = {20, 64, 0, 0}; 
	const int NB_S2_PHYS[] = {14, 28, 0, 21}; 
	const int NB_S2_INFO[] = {10, 32, 0, 21};
	const int NB_S2_CHIM[] = {14, 28, 0, 21};  
	const int NB_S2_FRANCAIS[] = {0, 42, 0, 0}; 
	const int NB_S2_ANGLAIS[] = {0, 42, 0, 0}; 
	const int NB_S2_OTHER[] = {0, 0, 8, 28};  //projet
	
	//Cours L1
	//S3 Commun
	const int NB_S3_MATH[] = {30, 0, 42, 0};
	const int NB_S3_FRANCAIS[] = {0, 36, 0, 0};
	const int NB_S3_ANGLAIS[] = {0, 36, 0, 0};
	const int NB_S3_OTHER[] = {0, 0, 0, 0};
	//Specialités
	const int NB_S3CE_PHYS[] = {48, 0, 48, 0};
	const int NB_S3CS_PHYS[] = {48, 0, 48, 0};
	const int NB_S3GE_PHYS[] = {48, 30, 48, 0}; // + Earth Science
	const int NB_S3OG_PHYS[] = {63, 0, 57, 6}; // + Elec
	const int NB_S3CE_INFO[] = {12, 0, 12, 12};
	const int NB_S3CS_INFO[] = {48, 0, 33, 45}; // + Admin et C
	const int NB_S3GE_INFO[] = {12, 0, 12, 12};
	const int NB_S3OG_INFO[] = {12, 0, 12, 12};
	const int NB_S3CE_CHIM[] = {45, 0, 36, 36}; //Chemical eng + chem
	const int NB_S3CS_CHIM[] = {0, 0, 0, 0};
	const int NB_S3GE_CHIM[] = {30, 0, 21, 21};
	const int NB_S3OG_CHIM[] = {30, 0, 21, 21};
	
	//S4 Commun
	const int NB_S4_FRANCAIS[] = {0, 36, 0, 36};
	const int NB_S4_ANGLAIS[] = {0, 36, 0, 36};
	const int NB_S4_OTHER[] = {6, 0, 6, 6}; //introduction to the business world
	//Spec
	const int NB_S4CE_MATH[] = {30, 0, 42, 0};
	const int NB_S4CS_MATH[] = {30, 0, 42, 0};
	const int NB_S4GE_MATH[] = {30, 0, 42, 0};
	const int NB_S4OG_MATH[] = {45, 0, 48, 9}; // + Statistics
	const int NB_S4CE_PHYS[] = {36, 0, 36, 0};
	const int NB_S4CS_PHYS[] = {36, 0, 36, 0};
	const int NB_S4GE_PHYS[] = {36, 30, 36, 0}; // + Earth Science
	const int NB_S4OG_PHYS[] = {36, 0, 36, 0}; 
	const int NB_S4CE_INFO[] = {12, 0, 12, 12};
	const int NB_S4CS_INFO[] = {51, 0, 51, 36}; // + Data Structires and Archi
	const int NB_S4GE_INFO[] = {12, 0, 12, 12};
	const int NB_S4OG_INFO[] = {12, 0, 12, 12};
	const int NB_S4CE_CHIM[] = {45, 0, 45, 36}; //Chemical eng + chem
	const int NB_S4CS_CHIM[] = {0, 0, 0, 0};
	const int NB_S4GE_CHIM[] = {30, 0, 30, 21};
	const int NB_S4OG_CHIM[] = {30, 0, 30, 21};

	int compteur = 0;
	for(int i=0; i<4; i++)
	{
		compteur += NB_S1_MATH[i] * NB_GROUPES_L0;
		compteur += NB_S1_PHYS[i] * NB_GROUPES_L0;
		compteur += NB_S1_CHIM[i] * NB_GROUPES_L0;
		compteur += NB_S1_INFO[i] * NB_GROUPES_L0;
		compteur += NB_S1_FRANCAIS[i] * NB_GROUPES_L0;
		compteur += NB_S1_ANGLAIS[i] * NB_GROUPES_L0;
		compteur += NB_S1_OTHER[i] * NB_GROUPES_L0;
		compteur += NB_S2_MATH[i] * NB_GROUPES_L0;
		compteur += NB_S2_PHYS[i] * NB_GROUPES_L0;
		compteur += NB_S2_INFO[i] * NB_GROUPES_L0;
		compteur += NB_S2_CHIM[i] * NB_GROUPES_L0;
		compteur += NB_S2_FRANCAIS[i] * NB_GROUPES_L0;
		compteur += NB_S2_ANGLAIS[i] * NB_GROUPES_L0;
		compteur += NB_S2_OTHER[i] * NB_GROUPES_L0;
		compteur += NB_S3_MATH[i] * NB_GROUPES_L1;
		compteur += NB_S3_FRANCAIS[i] * NB_GROUPES_L1;
		compteur += NB_S3_ANGLAIS[i] * NB_GROUPES_L1;
		compteur += NB_S3_OTHER[i] * NB_GROUPES_L1;
		compteur += NB_S3CE_PHYS[i] * NB_GROUPES_CE;
		compteur += NB_S3CS_PHYS[i] * NB_GROUPES_CS;
		compteur += NB_S3GE_PHYS[i] * NB_GROUPES_GE;
		compteur += NB_S3OG_PHYS[i] * NB_GROUPES_OG;
		compteur += NB_S3CE_INFO[i] * NB_GROUPES_CE;
		compteur += NB_S3CS_INFO[i] * NB_GROUPES_CS;
		compteur += NB_S3GE_INFO[i] * NB_GROUPES_GE;
		compteur += NB_S3OG_INFO[i] * NB_GROUPES_OG;
		compteur += NB_S3CE_CHIM[i] * NB_GROUPES_CE;
		compteur += NB_S3CS_CHIM[i] * NB_GROUPES_CS;
		compteur += NB_S3GE_CHIM[i] * NB_GROUPES_GE;
		compteur += NB_S3OG_CHIM[i] * NB_GROUPES_OG;
		compteur += NB_S4_FRANCAIS[i] * NB_GROUPES_L1;
		compteur += NB_S4_ANGLAIS[i] * NB_GROUPES_L1;
		compteur += NB_S4_OTHER[i] * NB_GROUPES_L1;
		compteur += NB_S4CE_MATH[i] * NB_GROUPES_CE;
		compteur += NB_S4CS_MATH[i] * NB_GROUPES_CS;
		compteur += NB_S4GE_MATH[i] * NB_GROUPES_GE;
		compteur += NB_S4OG_MATH[i] * NB_GROUPES_OG;
		compteur += NB_S4CE_PHYS[i] * NB_GROUPES_CE;
		compteur += NB_S4CS_PHYS[i] * NB_GROUPES_CS;
		compteur += NB_S4GE_PHYS[i] * NB_GROUPES_GE;
		compteur += NB_S4OG_PHYS[i] * NB_GROUPES_OG;
		compteur += NB_S4CE_INFO[i] * NB_GROUPES_CE;
		compteur += NB_S4CS_INFO[i] * NB_GROUPES_CS;
		compteur += NB_S4GE_INFO[i] * NB_GROUPES_GE;
		compteur += NB_S4OG_INFO[i] * NB_GROUPES_OG;
		compteur += NB_S4CE_CHIM[i] * NB_GROUPES_CE;
		compteur += NB_S4CS_CHIM[i] * NB_GROUPES_CS;
		compteur += NB_S4GE_CHIM[i] * NB_GROUPES_GE;
		compteur += NB_S4OG_CHIM[i] * NB_GROUPES_OG;
	}

	const int NB_COURS = compteur;
	
\end

\User functions:
	/* fonction d'affichage */
	string cmpTiret(int unsigned n)
	{
		string Emot = "";
		while (Emot.length() < n)
		{
			Emot += "-";
		} 
		return Emot;
	}
	/* Fonctions d'affichage, utilisées pour placer des espaces à coté du texte.			*/
	string cmpEspaceAlignGauche(string mot, int unsigned n)
		{ string Emot = mot; if ((Emot.length() > n) && (n > 2)) { Emot = mot.substr(0,n-3) + "..."; }
		while (Emot.length() < n) { Emot = Emot + " "; } return Emot; }
	string cmpEspaceAlignCentre(string mot, int unsigned n)
		{ string Emot = mot; bool pos = true; if ((Emot.length() > n) && (n > 2)) { Emot = mot.substr(0,n-3) + "..."; }
		while (Emot.length() < n) { if (pos) { Emot = Emot + " "; pos = false; }  else { Emot = " " + Emot; pos = true; } } return Emot; }
	string cmpEspaceAlignDroite(string mot, int unsigned n)
		{ string Emot = mot; if ((Emot.length() > n) && (n > 2)) { Emot = mot.substr(0,n-3) + "..."; }
		while (Emot.length() < n) { Emot = + " " + Emot; } return Emot; }
	/* Fonction de convertion, permet de changer une valeur numérique en texte pour son affichage	*/
	template<typename T>
	string chiffre2string(T c)
	{
		ostringstream oss;
		oss << c;
		return oss.str();
	}

	int**
\end

/* -------------------------------------------------------------------------------------------- */

/************************************************************************************************/
/*******************///             DECLARATION DES CLASSES               ///********************/
/************************************************************************************************/
\User classes :

/* Classe représentant un cours. Un cours se compose de chaque élément ci-dessous.		*/
Cours
{
	int		groupe;					/* représente le groupe participant (initialisé à GROUPE_LIBRE si pas de groupe)	*/
	int		matiere;				/* représente une matière		*/
    int		type;					/* type du cours (CM, CI, TD, TP)*/
 	int		prof;					/* représente un prof			*/
	int		salle;					/* représente une salle			*/
	int		creneau;				/* représente un créneau (de 0 à NB_CRENEAUX)	*/
}

/* Classe représentant un groupe de TP de 20 etudiants.					*/
Groupe
{
	int		specialisation;				/* type de diplome */
	int		occupation	[NB_CRENEAUX];	/* indique si présente dans le créneau	*/
	//si matiere[i] == COURS_LIBRE -> pas d'occupation
	int		matiere		[NB_CRENEAUX];	/* indique la matière dans le créneau	*/
	int 	coursSuivis[NB_MATIERES][NB_TYPES_COURS]; /* indique le nombre de cours suivis de chaque matiere et type */
}

/* Classe représentant un enseignant.							*/
Prof
{
	char 	id; //correspond à A,B,C ou D sur le sujet
	int 	type; //prof plein-temps, mi-temps ou vacataire
	int		potentiel;						/* indique son nombre d'horaires	*/
	int		occupation	[NB_CRENEAUX];	/* nombre de cours sur un même creneau */
	int		matiere;						//matiere enseignée par le prof
	int		groupe		[NB_CRENEAUX];		/* indique le group dans le créneau	*/
}

/* Classe représentant une salle de cours.							*/
Salle
{
	int		potentiel;					/* indique le nombre d'élève max dans la salle */
	int		type;						//type de la salle
	int		occupation	[NB_CRENEAUX];	/* indique si occupée dans le créneau	*/
}

Creneau
{
	int horaire; //0 -> 8H30, 1 -> 10H15, 2 -> 12H45, 3 -> 14H30
	int potentiel; // initialisé à NB_SALLES, si < 0, il y plus de cours qui de salles le même jour au même creneau
}

/* Classe représentant un génome, soit un emplois du temps complet.				*/
GenomeClass
{ 
	Cours*	cours			[NB_COURS];	/* les cours				*/
	Groupe*	groupes			[NB_GROUPES];	/* les groupes TP				*/
	Prof*	profs			[NB_PROFS];	/* les profs				*/
	Salle*	salles			[NB_SALLES];	/* les salles				*/
	Creneau* 	creneaux		[NB_CRENEAUX]; /* les creneaux */
}

\end
/* -------------------------------------------------------------------------------------------- */

\GenomeClass::display:
	//TODO affichage console
	std::cout << NB_PROFS << std::endl;
\end

\GenomeClass::initialiser:

	//initialisation des groupes de TP

	Groupe* g;
	int i = NB_GROUPES_L0;
	for(int i=0; i<NB_GROUPES; i++) 
	{
		g = new Groupe();
		if(i<NB_GROUPES_L0)
		{
			g->specialisation = SPEC_L0;
		}
		else if(i<NB_GROUPES_L0 + NB_GROUPES_CE)
		{
			g->specialisation = SPEC_CE;
		}
		else if(i<NB_GROUPES_L0 + NB_GROUPES_CE + NB_GROUPES_CS)
		{
			g->specialisation = SPEC_CS;
		}
		else if(i < NB_GROUPES_L0 + NB_GROUPES_CE + NB_GROUPES_CS + NB_GROUPES_GE)
		{
			g->specialisation = SPEC_GE;
		}
		else
		{
			g->specialisation = SPEC_OG;
		}
		Genome.groupes[i] = g;
	}

	//initialisation des profs
	for(int i=0; i<NB_PROFS; i++)
	{
		Genome.profs[i] = new Prof();
	}
	int compteur = 0;
	for(int i=0; i<NB_PROF_MATH; i++) 
	{
		Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
		Genome.profs[compteur]->matiere = PROF_MATH;
		Genome.profs[compteur]->id = (char)('A' + i);
		compteur++;
	}
	for(int i=0; i<NB_PROF_PHYSIQUE; i++) 
	{
		Genome.profs[compteur]->matiere = PROF_PHYSIQUE;
		Genome.profs[compteur]->id = (char)('A' + i);
		if(i < 2)
		{
			Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
		}
		else if(i == 3)
		{
			Genome.profs[compteur]->type = PROF_MI_TEMPS;
		}
		else
		{
			Genome.profs[compteur]->type = PROF_VACATAIRE;
		}
		compteur++;
	}
	for(int i=0; i<NB_PROF_INFO; i++) 
	{
		Genome.profs[compteur]->matiere = PROF_INFO;
		Genome.profs[compteur]->id = (char)('A' + i);
		if(i < 2)
		{
			Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
		}
		else if(i == 3)
		{
			Genome.profs[compteur]->type = PROF_MI_TEMPS;
		}
		else
		{
			Genome.profs[compteur]->type = PROF_VACATAIRE;
		}
		compteur++;
	}
	for(int i=0; i<NB_PROF_CHIMIE; i++) 
	{
		Genome.profs[compteur]->matiere = PROF_CHIMIE;
		Genome.profs[compteur]->id = (char)('A' + i);
		if(i < 2)
		{
			Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
		}
		else
		{
			Genome.profs[compteur]->type = PROF_MI_TEMPS;
		}
		compteur++;
	}
	for(int i=0; i<NB_PROF_ANGLAIS; i++) 
	{
		Genome.profs[compteur]->matiere = PROF_ANGLAIS;
		Genome.profs[compteur]->id = (char)('A' + i);
		Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
		compteur++;
	}
	for(int i=0; i<NB_PROF_FRANCAIS; i++) 
	{
		Genome.profs[compteur]->matiere = PROF_FRANCAIS;
		Genome.profs[compteur]->id = (char)('A' + i);
		if(i < 2)
		{
			Genome.profs[compteur]->type = PROF_PLEIN_TEMPS;
		}
		else if(i < 4)
		{
			Genome.profs[compteur]->type = PROF_MI_TEMPS;
		}
		else
		{
			Genome.profs[compteur]->type = PROF_VACATAIRE;
		}
		compteur++;
	}

	//initialisation des salles

	for(int i=0; i<NB_SALLES; i++)
	{
		Genome.salles[i]			= new Salle();
		if(i<2)
		{
			Genome.salles[i]->type			= SALLE_CM;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_CM;
		}
		else if(i < 7)
		{
			Genome.salles[i]->type			= SALLE_TD;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_TD;
		}
		else if(i < 14)
		{
			Genome.salles[i]->type			= SALLE_LANG;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_LANG;
		}
		else if(i < 16)
		{
			Genome.salles[i]->type			= SALLE_INFO;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_INFO;
		}
		else
		{
			Genome.salles[i]->type			= SALLE_LABO;
			Genome.salles[i]->potentiel		= CAPACITE_SALLE_LABO;
		}
	}

	//initialisation des cours
	for(int i=0; i<NB_COURS; i++) 
	{
		Genome.cours[i]			= new Cours();
	}

	//initialisation des creneaux
	for(int i=0; i<NB_CRENEAUX; i++) 
	{
		Genome.creneaux[i] = new Creneau();
	}

	//TODO poser tous les cours pour les groupes suivant s'ils sont disponible (semi-aléatoire)
	//faire un tirage aléatoire jusqu'a tomber sur un créneau ou le groupe sont libre et ou au moins une salle est libre
	//TODO tenter de faire un tirage aléatoire pour placer les profs et les salles sinon diriger le tirage aléatoire
	for (int i=0; i<NB_COURS; i++)
	{
		int j = Genome.cours[i]->creneau;
		Genome.groupes	[Genome.cours[i]->groupe]	->occupation[j]++;
		Genome.groupes	[Genome.cours[i]->groupe]	->matiere[j] 		= Genome.cours[i]->matiere;
		Genome.profs	[Genome.cours[i]->prof]		->potentiel[j]--;
		Genome.profs	[Genome.cours[i]->prof]		->classe[j] 		= Genome.cours[i]->groupes;
		Genome.salles	[Genome.cours[i]->salle]	->potentiel[j]--;
		Genome.creneaux	[j]							->potentiel--;
	}
\end

\GenomeClass::crossover:
	//pour chaque cours, 1 chance sur 2 de garder le creneau
	for (int i=0; i<NB_COURS; i++)
	{
		if(random(0.0,1.0) < 0.5)
		{
			child.cours[i]->creneau = parent2.cours[i]->creneau;
		}
	}
\end

\GenomeClass::mutator:
	int	nb_mutation = 0;

	/* -------------------------------------------------------------------------------------------- */
	/* EVALUATION DES CRENEAUX									*/
	/* -------------------------------------------------------------------------------------------- */

	/* Initialisation des compteurs 								*/
	for (int k=0; k<NB_GROUPES; k++)
	{
		if (Genome.groupes[k] == NULL)
		{
			Genome.groupes[k]= new Groupe();
		}

		for(int j=0; j<NB_CRENEAUX; j++)
		{
			Genome.groupes[k]->occupation[j]= 0;
		}
	}

	for (int k=0; k<NB_PROFS; k++)
	{
		if (Genome.profs[k] == NULL)
		{
			Genome.profs[k]= new Prof();
		}

		for(int j=0; j<NB_CRENEAUX; j++)
		{
			Genome.profs[k]->occupation[j]= COURS_LIBRE;
		}
	}

	for (int k=0; k<NB_SALLES; k++)
	{	
		if (Genome.salles[k] == NULL)
		{
			Genome.salles[k]= new Salle();
		}

		for(int j=0; j<NB_CRENEAUX; j++)
		{
			Genome.salles[k]->occupation[j]	= COURS_LIBRE;
		}
	}

	for (int j=0; j<NB_CRENEAUX; j++)
	{	
		if (Genome.creneaux[j] == NULL)
		{
			Genome.creneaux[j]	= new Creneau();
		}
		Genome.creneaux[j]->potentiel= NB_SALLES;
	}

	/* Affectation des compteurs 									*/
	for (int i=0; i<NB_COURS; i++)
	{
		int j = Genome.cours[i]->creneau;
		Genome.groupes[Genome.cours[i]->groupes]->occupation[j]++;
		Genome.profs[Genome.cours[i]->prof]	->occupation[j]++;
		Genome.salles[Genome.cours[i]->salle]->occupation[j]++;
		Genome.creneaux[j]->potentiel--;
	}


	/* Analyse & Modification des compteurs 							*/
	for (int i=0; i<NB_COURS; i++)
	{
		int	j= Genome.cours[i]->creneau;
		int	c= Genome.cours[i]->groupes;
		int	p= Genome.cours[i]->prof;
		int	s= Genome.cours[i]->salle;
		int	err	= 0;
		int	r= j;
			
	/* en cas de mutation, on échange deux profs de même matière					*/
	/*
		if (sigmaP < pMutPerGene)
		{
	//		cout<<"MUTATION !!"<<endl;
			int k		= 0;
			int minprof	= 0;
			int maxprof	= nbProfsTx[k];
			int y		= 0;
				
			while (p > maxprof)
			{
				minprof = maxprof;
				maxprof += nbProfsTx[++k];
			}
				
			if (p == maxprof)
			{
				y = minprof;
			}
			else
			{
				y = p+1;
			}
				
			for (int x=0; x<NB_COURS; x++)
			{
				if (Genome.cours[x]->prof == y)
				{
	//				cout<<"On remplace :"<<chiffre2string(p)<<" par "<<chiffre2string(y)<<endl;
					Genome.cours[x]->prof = p;
					Genome.profs	[p]	->occupation[Genome.cours[x]->creneau]++;
					Genome.profs	[y]	->occupation[Genome.cours[x]->creneau]--;
					Genome.cours[i]->prof = y;
					Genome.profs	[y]	->occupation[j]++;
					Genome.profs	[p]	->occupation[j]--;
					break;
				}
			}
		}
		*/

	/* on vérifie l'occupation des éléments du cours 						*/
		
		if (err == 0)
		{
			if (Genome.groupes[c]->occupation[j] > 1)
			{
				err = 1;
			}
			if (Genome.profs[p]->occupation[j] > 1)
			{
				err = 2;
			}
			if (Genome.salles[s]->occupation[j] > 1)
			{
				err = 3;
			}
		}

	/* en cas d'erreur, on "corrige" le cours en le réinitialisant de manière valide.		*/
		if (err > 0)
		{
			nb++;
			r 	= j;
			int mode = 1;
			do
			{
				r = (r + 1)%NB_CRENEAUX;
				if (r == j)
				{
					if (mode == 2)
					{
						break;
					}
					else
					{
						mode++;
					}
				}
			}
			while
			(
				(Genome.creneaux[r]->potentiel <= 0) ||
				(
					((Genome.creneaux[r]->potentiel == NB_SALLES) && (mode < 2)) ||
					(Genome.groupes	[c]	->occupation[r] > 0) ||
					(Genome.profs	[p]	->occupation[r] > 0) ||
					(Genome.salles	[s]	->occupation[r] > 0)
				)
			);
			
			Genome.groupes	[c]	->occupation[j]--;
			Genome.profs	[p]	->occupation[j]--;
			Genome.salles	[s]	->occupation[j]--;
			Genome.creneaux	[j]	->potentiel++;
			
			Genome.groupes	[c]	->occupation[r]++;
			Genome.profs	[p]	->occupation[r]++;
			Genome.salles	[s]	->occupation[r]++;
			Genome.creneaux	[r]	->potentiel--;
		}

		Genome.cours[i]->creneau = r;
	}

	return nb;
\end

\GenomeClass::evaluator:
	int evaluation = 0;

	//initialisation des compteurs à des valeurs par défaut
	for(int i=0; i<NB_GROUPES; i++)
	{
		if(Genome.groupes[i] == NULL)
		{
			Genome.groupes[i] = new Groupe();
		}
		for(int j=0; j<NB_CRENEAUX; j++)
		{
			Genome.groupes[i]->occupation[j] = 0;
			Genome.groupes[i]->matiere[j] = COURS_LIBRE;
		}
		for(int j=0; j<NB_COURS; j++)
		{
			for(int k=0; k<NB_TYPES_COURS; k++)
			{
				Genome.groupes[i]->coursSuivis[j][k] = 0;
			}
		}
	}

	for(int i=0; i<NB_PROFS; i++)
	{
		if(Genome.profs[i] == NULL)
		{
			Genome.profs[i] = new Prof();
		}
		switch(Genome.profs[i]->type)
		{
			case PROF_PLEIN_TEMPS:
				Genome.profs[i]->potentiel = NB_HEURES_PLEIN_TEMPS;
				break;
			case PROF_MI_TEMPS:
				Genome.profs[i]->potentiel = NB_HEURES_MI_TEMPS;
				break;
			default:
				Genome.profs[i]->potentiel = NB_HEURES_VACATAIRE;
		}
		for(int j=0; j<NB_CRENEAUX; j++)
		{
			Genome.profs[i]->occupation[j] = 0;
			Genome.profs[i]->classe[j] = COURS_LIBRE;
		} 
	}

	for(int i=0; i<NB_SALLES; i++)
	{
		if(Genome.salles[i] == NULL)
		{
			Genome.salles[i] = new Salle();
		}
		for(int j=0; j<NB_CRENEAUX; j++)
		{
			Genome.salles[i]->occupation[j] = 0;
		} 
	}

	for(int i=0; i<NB_CRENEAUX; i++)
	{
		if(Genome.creneaux[i] == NULL)
		{
			Genome.creneaux[i] = new Creneau();
		}
		Genome.creneaux[i]->potentiel = NB_SALLES;
	}

	int creneau, groupe, prof, matiere, type;
	for(int i=0; i<NB_COURS; i++)
	{
		//Creneau du cours
		creneau = Genome.cours[i]->creneau;
		//groupe du cours
		groupe = Genome.cours[i]->groupe;
		//prof du cours
		prof = Genome.cours[i]->prof;
		//matiere du cours
		matiere = Genome.cours[i]->matiere;
		//type du cours
		type = Genome.cours[i]->type;
		//Le groupe du cours est occupé pour ce créneau
		Genome.groupes[groupe]->occupation[creneau]++;
		//La matiere que suit le groupe à ce creneau est celle du cours
		Genome.groupes[groupe]->matiere[creneau] = matiere;
		//Le prof du cours est occupé pour ce créneau
		Genome.profs[prof]->occupation[creneau]++;
		//Le prof enseigne au groupe de ce cours
		Genome.profs[prof]->groupe[creneau] = groupe;
		//La salle est occupé par un groupe
		Genome.salles[Genome.cours[i]->salle]->occupation[creneau]++;
		//Le contient un cours supplémentaire
		Genome.creneaux[creneau]->potentiel--;
		//Le groupes suis un cours supplémentaire
		Genome.groupes[groupe]->coursSuivis[matiere][type]++;
	}

	//Évaluation des occupations pour les groupes, les profs, les salles et les creneaux
	int compteurCoursGroupe = 0, compteurCoursProf = 0;
	for(int i=0; i<NB_CRENEAUX; i++)
	{
		for(int j=0; j<NB_GROUPES; j++)
		{
			if(Genome.groupes[j]->matiere[i] != COURS_LIBRE)
			{
				compteurCoursGroupe++;
			}
			if(Genome.groupes[j]->occupation[i] > 1)
			{
				//plus d'un cours en même temps 
				evaluation += PENALITE_OBLIGATOIRE;
			}
			for(int k=0; k<NB_MATIERES; k++)
			{
				for(int l=0; l<NB_TYPES_COURS; l++)
				{
					if(Genome.groupes[j]->coursSuivis[k][l] != 0)
					{
						//Mauvais nombre d'heures suivis
						evaluation += PENALITE_FORTE;
					}
				}
			}
		}

		for(int j=0; j<NB_PROFS; j++)
		{
			if(Genome.profs[j]->matiere[i] != COURS_LIBRE)
			{
				compteurCoursProf++;
			}
			if(Genome.profs[j]->occupation[i] > 1)
			{
				//plus d'un cours en même temps 
				evaluation += PENALITE_OBLIGATOIRE;
			}
		}

		if(i % NB_CRENEAUX_JOUR == 0)
		{
			if(compteurCoursGroupe == 1 || compteurCoursGroupe == NB_CRENEAUX_JOUR)
			{
				//Un seul cours, ou journée complète
				evaluation += PENALITE_FORTE;
			}
			if(compteurCoursProf == 1 || compteurCoursProf == NB_CRENEAUX_JOUR)
			{
				//Un seul cours, ou journée complète
				evaluation += PENALITE_FORTE;
			}
			compteurCoursGroupe = 0;
			compteurCoursProf = 0;
		}

		for(int j=0; j<NB_SALLES; j++)
		{
			if(Genome.salles[j]->occupation[i] > Genome.salles[j]->potentiel)
			{
				//plus de groupes que possible dans la salle
				evaluation += PENALITE_OBLIGATOIRE;
			}
		}

		if(Genome.creneaux[i]->potentiel < 0)
		{
			//plus de cours que dans salle
			evaluation += PENALITE_OBLIGATOIRE;
		}
	}

	//Évaluation des horaires effectués par les profs
	for(int j=0; j<NB_PROFS; j++)
	{
		if(Genome.profs[j]->potentiel[i] < 0)
		{
			if(Genome.profs[j]->type == PROF_VACATAIRE)
			{
				//Moins on doit payer de vacataire, mieux c'est
				evaluation += PENALITE_FAIBLE * -Genome.profs[j]->potentiel[i];
			}
			else
			{
				//On suppose que les heures supps ne sont pas tolérables
				evaluation += PENALITE_OBLIGATOIRE;
			}
		}
	}

	Cours* c;
	Salle* s;
	Prof* p;
	Groupe* g;
	for(int i=0; i<NB_COURS; i++)
	{
		c = Genome.cours[i];
		s = Genome.salles[c->salle];
		p = Genome.profs[c->prof];
		g = Genome.groupes[c->groupe];

		//Évaluation matiere / prof
		if(p->matiere != c->matiere)
		{
			evaluation += PENALITE_OBLIGATOIRE;
		}

		//Évaluation des types de salle pour chaque cours
		switch(c->type)
		{
			case COURS_CM:
				if(s->type != SALLE_CM)
				{
					evaluation += PENALITE_FORTE;
				}
				break;
			case COURS_CI:
			case COURS_TD:
			 	//on considère que les CI se passent dans les salles de TD
				if(s->type != SALLE_TD)
				{
					evaluation += PENALITE_FORTE;
				}
				break;
			case COURS_TP:
				switch(c->matiere)
				{
					case COURS_INFO:
						if(s->type != SALLE_INFO)
						{
							evaluation += PENALITE_FORTE;
						}
						break;
					case COURS_ANGLAIS:
					case COURS_FRANCAIS:
						if(s->type != SALLE_LANG)
						{
							evaluation += PENALITE_FORTE;
						}
						break;
					case COURS_CHIMIE:
					case COURS_PHYSIQUE:
						if(s->type != SALLE_LABO)
						{
							evaluation += PENALITE_FORTE;
						}
						break;
					default:
						evaluation += PENALITE_FORTE;
				}
				break;
			default:;
		}
	}

	//pénalités faibles si plusieurs même cours dans une même journée par groupe
	for(int i=0; i<NB_GROUPES; i++)
	{
		compteursPlusCours = 0;
		for(int j=0; j<NB_CRENEAUX; j= j+NB_CRENEAUX_JOUR){
			for(int k=0; k<(NB_CRENEAUX_JOUR-1); k++){
				if(Genome.groupes[i]->matiere[j+k] == Genome.groupes[i]->matiere[j+k+1]){
					compteursPlusCours++;
				}
			}
			if(compteursPlusCours > 1){
				evaluation += PENALITE_FAIBLE;
			}
			compteursPlusCours = 0;
		}
		
	}
	//pénalités faibles par trou dans une journée travaillée
	for(int i=0; i<NB_PROFS; i++)
	{
		compteursTrou = 0;
		for(int j=0; j<NB_CRENEAUX; j+=NB_CRENEAUX_JOUR){
			for(int k=0; k<(NB_CRENEAUX_JOUR-1); k++){
				if(Genome.profs[i]->matiere[j+k] != COURS_LIBRE){
					if(Genome.profs[i]->matiere[j+k+1] == COURS_LIBRE){
						compteursTrou++;
					}
				}
			}
			if(compteursTrou > 0){
				evaluation += PENALITE_FAIBLE;
			}
			compteursTrou = 0;
		}
		
	}

	return evaluation;
\end

\User Makefile options:
	CXXFLAGS+=-std=c++98
\end

\Default run parameters :
  Number of generations : 100
  Time limit: 10
  Population size : 100
  Offspring size : 40%
  Mutation probability : 1
  Crossover probability : 1
  Evaluator goal : Minimise
  Selection operator: Tournament 2.0
  Surviving parents: 90%
  Surviving offspring: 90%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong
  Elite: 1
  Print stats: true
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:false

  Remote island model: false
  Migration probability: 0

  Save population: false
  Start from file:false
\end