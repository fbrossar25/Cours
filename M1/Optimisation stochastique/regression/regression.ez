/*_________________________________________________________

  This is a standard GP implementation on EASEA, 
  aimed for regression.

  use : easea -gp regression.ez
	make

	OR (if you'd like to exploit a CUDA-compatible graphic card)

	easea -cuda_gp regression.ez
        make

  in order to generate and compile this code.
__________________________________________________________*/

\User declarations :
#include<math.h>
#include<stdlib.h>
// these 3 defines are mandatory here. Adjust as you like.
#define NO_FITNESS_CASES 84
#define VAR_LEN 1
#define GROW_FULL_RATIO 0.5

// this is the number of learning cases computed in parallel.
// note that on 1024 is the maximum size on fermi architectures 512 on older cards.
#define NUMTHREAD 1024
#define MAX_STACK 15


#define PI (3.141592653589793)
\end

\User functions:
// #define POLY(x) x*x/(x+1)-abs(x)
/**
   This function generates data NO_FITNESS_CASES fitness cases,
   from the polynome POLY(X) with X randomly picked between (-1,1)

   @inputs address of the inputs array. (array will be allocated here)
   @outputs adddress of the outputs array. (array will be allocated here)

   @ret number of loaded fitness cases (should be equal to NO_FITNESS_CASES).   
 */

int generateData(float*** inputs, float** outputs){
  int i=0;

  (*inputs) = new float*[NO_FITNESS_CASES];
  (*outputs) = new float[NO_FITNESS_CASES];

/*
  for( i=0 ; i<NO_FITNESS_CASES ; i++ ){
    (*inputs)[i]=new float[VAR_LEN];
    float x = random(-10.,+10.);
    (*inputs)[i][0] = x;
    (*outputs)[i] = POLY(x);
  }
*/
  for( i=0 ; i<NO_FITNESS_CASES ; i++ )
    (*inputs)[i]=new float[VAR_LEN];

  (*inputs)[0][0] = 23;      (*outputs)[0]=86406;
  (*inputs)[1][0] = 99;      (*outputs)[1]=43403;
  (*inputs)[2][0] = 3994;    (*outputs)[2]=30711;
  (*inputs)[3][0] = 4015;    (*outputs)[3]=30240;
  (*inputs)[4][0] = 10307;   (*outputs)[4]=30920;
  (*inputs)[5][0] = 10487;   (*outputs)[5]=30194;
  (*inputs)[6][0] = 16639;   (*outputs)[6]=29532;
  (*inputs)[7][0] = 16819;   (*outputs)[7]=29471;
  (*inputs)[8][0] = 22938;   (*outputs)[8]=29782;
  (*inputs)[9][0] = 22945;   (*outputs)[9]=29255;
  (*inputs)[10][0] = 29249;  (*outputs)[10]=28197;
  (*inputs)[11][0] = 29457;  (*outputs)[11]=28460;
  (*inputs)[12][0] = 35576;  (*outputs)[12]=27744;
  (*inputs)[13][0] = 35756;  (*outputs)[13]=27629;
  (*inputs)[14][0] = 41936;  (*outputs)[14]=26808;
  (*inputs)[15][0] = 41943;  (*outputs)[15]=26485;
  (*inputs)[16][0] = 48221;  (*outputs)[16]=25156;
  (*inputs)[17][0] = 48303;  (*outputs)[17]=24870;
  (*inputs)[18][0] = 54408;  (*outputs)[18]=24264;
  (*inputs)[19][0] = 54588;  (*outputs)[19]=24176;
  (*inputs)[20][0] = 60588;  (*outputs)[20]=22571;
  (*inputs)[21][0] = 60782;  (*outputs)[21]=23287;
  (*inputs)[22][0] = 67046;  (*outputs)[22]=21568;
  (*inputs)[23][0] = 67212;  (*outputs)[23]=22254;
  (*inputs)[24][0] = 73219;  (*outputs)[24]=20566;
  (*inputs)[25][0] = 73441;  (*outputs)[25]=20913;
  (*inputs)[26][0] = 79663;  (*outputs)[26]=19663;
  (*inputs)[27][0] = 79885;  (*outputs)[27]=19359;
  (*inputs)[28][0] = 85878;  (*outputs)[28]=18220;
  (*inputs)[29][0] = 86072;  (*outputs)[29]=18280;
  (*inputs)[30][0] = 92308;  (*outputs)[30]=17273;
  (*inputs)[31][0] = 92474;  (*outputs)[31]=17210;
  (*inputs)[32][0] = 98460;  (*outputs)[32]=15667;
  (*inputs)[33][0] = 98654;  (*outputs)[33]=16315;
  (*inputs)[34][0] = 104675; (*outputs)[34]=14463;
  (*inputs)[35][0] = 105042; (*outputs)[35]=14883;
  (*inputs)[36][0] = 111049; (*outputs)[36]=13969;
  (*inputs)[37][0] = 111313; (*outputs)[37]=14034;
  (*inputs)[38][0] = 117451; (*outputs)[38]=12977;
  (*inputs)[39][0] = 117743; (*outputs)[39]=12897;
  (*inputs)[40][0] = 123736; (*outputs)[40]=11851;
  (*inputs)[41][0] = 123916; (*outputs)[41]=11830;
  (*inputs)[42][0] = 130124; (*outputs)[42]=11129;
  (*inputs)[43][0] = 130360; (*outputs)[43]=11058;
  (*inputs)[44][0] = 136131; (*outputs)[44]=9998;
  (*inputs)[45][0] = 136526; (*outputs)[45]=10259;
  (*inputs)[46][0] = 142491; (*outputs)[46]=9408;
  (*inputs)[47][0] = 142783; (*outputs)[47]=9496;
  (*inputs)[48][0] = 148804; (*outputs)[48]=8797;
  (*inputs)[49][0] = 149157; (*outputs)[49]=8842;
  (*inputs)[50][0] = 154928; (*outputs)[50]=7863;
  (*inputs)[51][0] = 155136; (*outputs)[51]=8189;
  (*inputs)[52][0] = 161358; (*outputs)[52]=7471;
  (*inputs)[53][0] = 161524; (*outputs)[53]=7404;
  (*inputs)[54][0] = 167573; (*outputs)[54]=6851;
  (*inputs)[55][0] = 167767; (*outputs)[55]=7003;
  (*inputs)[56][0] = 173933; (*outputs)[56]=6500;
  (*inputs)[57][0] = 174239; (*outputs)[57]=6348;
  (*inputs)[58][0] = 180293; (*outputs)[58]=6025;
  (*inputs)[59][0] = 180613; (*outputs)[59]=6014;
  (*inputs)[60][0] = 186286; (*outputs)[60]=5503;
  (*inputs)[61][0] = 186564; (*outputs)[61]=5960;
  (*inputs)[62][0] = 192702; (*outputs)[62]=5564;
  (*inputs)[63][0] = 193092; (*outputs)[63]=5273;
  (*inputs)[64][0] = 198709; (*outputs)[64]=5068;
  (*inputs)[65][0] = 199015; (*outputs)[65]=5170;
  (*inputs)[66][0] = 205300; (*outputs)[66]=4697;
  (*inputs)[67][0] = 205653; (*outputs)[67]=4776;
  (*inputs)[68][0] = 211429; (*outputs)[68]=4441;
  (*inputs)[69][0] = 211646; (*outputs)[69]=4443;
  (*inputs)[70][0] = 217964; (*outputs)[70]=4284;
  (*inputs)[71][0] = 218298; (*outputs)[71]=4248;
  (*inputs)[72][0] = 224013; (*outputs)[72]=4178;
  (*inputs)[73][0] = 224366; (*outputs)[73]=4129;
  (*inputs)[74][0] = 230123; (*outputs)[74]=4085;
  (*inputs)[75][0] = 230485; (*outputs)[75]=4056;
  (*inputs)[76][0] = 236464; (*outputs)[76]=3785;
  (*inputs)[77][0] = 236775; (*outputs)[77]=3877;
  (*inputs)[78][0] = 242866; (*outputs)[78]=3639;
  (*inputs)[79][0] = 243060; (*outputs)[79]=3508;
  (*inputs)[80][0] = 248822; (*outputs)[80]=3489;
  (*inputs)[81][0] = 249170; (*outputs)[81]=3395;
  (*inputs)[82][0] = 254857; (*outputs)[82]=3244;
  (*inputs)[83][0] = 255691; (*outputs)[83]=3234;

  return NO_FITNESS_CASES;
}


void free_data(){
  for( int i=0 ; i<NO_FITNESS_CASES ;i++ ) delete[] inputs[i] ;

  delete[] outputs;
  delete[] inputs;
} 
\end



\Before everything else function:
{
  generateData(&inputs,&outputs);
}
\end

\After everything else function:
{
  std::cout << toString(((IndividualImpl*)EA->population->Best)->root) << std::endl;

  free_data();
}
\end

\At the beginning of each generation function:
{
  //cout << "At the beginning of each generation function called" << endl;
}		    
\end

\At the end of each generation function:
{		 
  //cout << "At the end of each generation function called" << endl;
}
\end

\At each generation before reduce function:
 //cout << "At each generation before replacement function called" << endl;
\end


\User classes :

GenomeClass {
  GPNode* root;
}
\end

\GenomeClass::display:

\end

\GenomeClass::initialiser :
{
  Genome.root = ramped_hh();
}
\end

\GenomeClass::crossover :
{
  simpleCrossOver(parent1,parent2,child);
  child.valid = false;
}
\end

\GenomeClass::mutator : // Must return the number of mutations
{
  simple_mutator(&Genome);

  return 1;
}
\end


\begin operator description :
OP_X, "x", 0, {RESULT=INPUT[0];}; //Nom de l'opérateur, symbole, arité, effet
OP_ERC, "ERC", 0, {RESULT=ERC;}; // Ephemeral Random Constant (une valeur)
OP_ADD, "+", 2, {RESULT=OP1+OP2;};
OP_SUB, "-", 2, {RESULT=OP1-OP2;};
OP_MUL, "*", 2, {RESULT=OP1*OP2;};
OP_EXP, "exp", 1, {RESULT=exp(OP1);};
\end


\GenomeClass::evaluator header:
/*
OP_DIV, "/", 2, {
  if( !OP2 ) RESULT = 1;
  else RESULT = OP1/OP2;
};
*/
\end

\GenomeClass::evaluator for each fc :
float expected_value = OUTPUT;
ERROR = (expected_value-EVOLVED_VALUE)*(expected_value-EVOLVED_VALUE);
\end

\GenomeClass::evaluator accumulator :
return sqrtf(ERROR);
\end


\User Makefile options: 

//CXXFLAGS+=I/usr/local/cuda/common/inc/ -I/usr/local/cuda/include/
LDFLAGS+=
\end

\Default run parameters :         // Please let the parameters appear in this order
  Number of generations : 50   	// NB_GEN
  Time limit: 0 			// In seconds, 0 to deactivate
  Population size : 5000			//POP_SIZE
  Offspring size : 5000 // 40% 
  Mutation probability : 0.1       // MUT_PROB
  Crossover probability : 0.9      // XOVER_PROB
  Evaluator goal : minimise      // Maximise
  Selection operator: Tournament 7
  Surviving parents: 100%//percentage or absolute  
  Surviving offspring: 100%
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 7

  Elitism: Strong			//Weak or Strong
  Elite: 1
  Print stats: true				//Default: 1
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				//Default: 0

  //  Remote island model: true
  //IP	  file: ip.txt 			//File containing all the remote island's IP
  //Server port : 2929
  //Migration probability: 0.33

  Save population: false
  Start from file: false

  max init tree depth : 4
  min init tree depth : 2

  max tree depth : 8

  size of prog buffer : 200000000
\end
